<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://www.dil.univ-mrs.fr/~chris/Perl/Packages.htm -->
<HTML><HEAD><TITLE>Cours Perl, les packages</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, les packages_fichiers/Messtyles.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Les packages.</H1>
<H2>Les packages.</H2>
<H3>Un "package" est un ensemble de noms réunis dans une table de symboles. Un 
programme donné peut définir le nombre de package dont il a besoin au moyen de 
l'instruction package. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>package mon_paquet;
  </PRE></DIV></DIV>
<H3>Cette instruction permet de créer le package "mon-paquet". Toutes les 
variables et tous les noms de procédures définies à partir de ce point seront 
stockées dans une table de symboles associée à ce nouveau package.<BR>Cet état 
de chose se poursuit jusqu'à la déclaration d'un nouveau package. </H3>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>c:\progs&gt; type pack1.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl -w
$variable = 0;
package paquet1;
  $variable = 100;
package paquet2;
  $variable = 200;
package paquet3;
  $variable = 300;
print ("On se positionne dans le package 1.\n");
package paquet1;
print ("la valeur de la variable est : $variable.\n");
print ("On se positionne dans le package 2.\n");
package paquet2;
print ("la valeur de la variable est : $variable.\n");
print ("On se positionne dans le package 3.\n");
package paquet3;
print ("la valeur de la variable est : $variable.\n");
print ("On se positionne dans le package main.\n");
package main;
print ("la valeur de la variable est : $variable.\n");
c:\progs&gt; perl pack1.pl<SPAN class=rouge>ent</SPAN>
On se positionne dans le package 1.
la valeur de la variable est : 100.
On se positionne dans le package 2.
la valeur de la variable est : 200.
On se positionne dans le package 3.
la valeur de la variable est : 300.
On se positionne dans le package main.
la valeur de la variable est : 0.
c:\progs&gt;
  </PRE></DIV></DIV>
<H3>A noter que le package par défaut est main. </H3>
<H3>Attention aux erreurs de référencement, dans l'exemple suivant on fait appel 
à une procédure &amp;imprime à partir du package courant qui se trouve être 
"paquet1"<BR>Cette procédure n'est pas définie dans ce package mais dans "main", 
d'où le message d'erreur. </H3>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>c:\progs&gt; type pack2.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
sub imprime {
print ("la valeur de la variable est : $_.\n");
}
$variable = 0;
package paquet1;
  $variable = 100;
print ("On se positionne dans le package 1.\n");
package paquet1;
&amp;imprime;
c:\progs&gt; perl pack2.pl<SPAN class=rouge>ent</SPAN>
On se positionne dans le package 1.
# Undefined subroutine &amp;paquet1::imprime called.
File 'pack2.pl'; Line 11
c:\progs&gt;
  </PRE></DIV></DIV>
<H2>Référence à un paquet.</H2>
<H3>On peut faire référence à un objet extérieur au package courant en 
spécifiant explicitement son appartenance. </H3>
<H3>Il est donc possible de faire référence à une procédure sous la forme. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>&amp;nom_de_package::nom_de_procedure (@liste);
  </PRE></DIV></DIV>
<H3>A un scalaire sous la forme. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>$nom_de_package::nom_de_scalaire;
  </PRE></DIV></DIV>
<H3>A une liste sous la forme. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>@nom_de_package::nom_de_liste;
  </PRE></DIV></DIV>
<H3>A un hash sous la forme. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>%nom_de_package::nom_de_hash;
  </PRE></DIV></DIV>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>c:\progs&gt; type pack3.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
sub imprime {
  print ("la valeur de la variable est : @_.\n");
}
$variable = 0;
package paquet1;
  $variable = 100;
package paquet2;
  $variable = 200;
package paquet3;
  $variable = 300;
print ("On se positionne dans le package 1.\n");
package paquet1;
  &amp;main::imprime ($variable);
  print ("On se positionne dans le package 2.\n");
package paquet2;
  &amp;main::imprime ($variable);
  print ("On se positionne dans le package 3.\n");
package paquet3;
  &amp;main::imprime ($variable);
  print ("On se positionne dans le package main.\n");
package main;
  &amp;main::imprime ($variable);
c:\progs&gt; perl pack3.pl<SPAN class=rouge>ent</SPAN>
On se positionne dans le package 1.
la valeur de la variable est : 100.
On se positionne dans le package 2.
la valeur de la variable est : 200.
On se positionne dans le package 3.
la valeur de la variable est : 300.
On se positionne dans le package main.
la valeur de la variable est : 0.
c:\progs&gt;
  </PRE></DIV></DIV>
<H2>Remarque historique.</H2>
<H3>En perl 5, la référence nom::package correspond à la référence nom'package 
de perl 4.<BR>Le probleme de la seconde notation, c'est davantage de savoir 
comment va s'interpreter une référence de la forme $abc'def'ghi<BR>Le fait 
d'utiliser le :: comme separateur d'espaces de noms, présente entre autres 
avantages, outre le fait d'avoir une représentation qui rejoint celles de C++ et 
de Java, celui de n'avoir aucun doute quand à la signification de $abc::def::ghi 
</H3>
<H2>Références à des modules (require).</H2>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>c:\progs&gt; type prive.pm<SPAN class=rouge>ent</SPAN> 
package main;
# Lien vers le monde extérieur, le package main.
# Dans main on définit un sous programme imprime qui
# pointe vers un sous programme dans le package privé.
  sub imprime {
    &amp;prive::imprime (@_);
  }

package prive;
# Le sous programme imprime du package prive.
  sub imprime {
    print ("@_\n");
 }
# Retour au package main pour définir une variable de
# retour différente de undef.
package main;
  "vrai";
c:\progs&gt; type pack4.pl<SPAN class=rouge>ent</SPAN>
#!/usr/bin/perl -w
require ("prive.pm");
$nombre = 2000;
&amp;prive::imprime ("Valeur = $nombre\n");
c:\progs&gt; perl pack4.pl<SPAN class=rouge>ent</SPAN>
Valeur = 2000
c:\progs&gt;
  </PRE></DIV></DIV>
<H2>Références à des modules (use).</H2>
<H3>Il est aussi possible de faire référence à un module au moyen de la commande 
use. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>use nom_de_module;
  </PRE></DIV></DIV>
<H3>Le nom ainsi spécifié est automatiquement affecté de l'extention .pm (perl 
module). </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme pack5.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
use prive;
$nombre = 2000;
&amp;prive::imprime ("Valeur = $nombre\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl pack5.pl<SPAN class=rouge>ent</SPAN>
Valeur = 2000
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Un module qui a été appelé au moyen de la commande use peut être libéré au 
moyen de la commande. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>no nom_de_module;
  </PRE></DIV></DIV>
<H3>La différence fondamentale entre "require" et "use"tient essentiellement au 
fait que use effectue un import qui a pour effet d'importer les définitions dans 
l'espace du package courant.<BR>Par exemple, si nous considérons un module ls.pm 
qui contenant une fonction lister(). </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>require ls; $fichiers=ls::lister();
  </PRE></DIV></DIV>
<H3>Permet d'accéder à la fonction lister() du module ls.pm. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>use ls; $fichiers=lister();
  </PRE></DIV></DIV>
<H3>Importe la fonction lister() du module ls.pm. </H3>
<H3>Alors que. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>require ls; $fichiers=lister();
  </PRE></DIV></DIV>
<H3>Provoque, comme on pouvait s'y attendre l'erreur : no main::lister(). </H3>
<H2>Le debugger.</H2>
<H3>Lorsqu'on doit mettre au point des programmes un peu compliqués, Perl met à 
la disposition du développeur un outil de mise au point.<BR>C'est un outil 
important et d'utilisation délicate qui comporte de nombreuses commandes.<BR>Il 
est conseillé, avant de l'utiliser de consulter le manuel afin d'en connaitre 
les fonctions. </H3>
<H2>Les modules.</H2>
<H3>Les modules Perl sont disponibles sur les divers CPAN. L'adresse générique 
du cpan (Comprehensive Perl Archive Network) est : </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD><A href="http://www.cpan.org/">http://www.cpan.org/</A></TD>
    <TD><IMG height=67 src="Cours Perl, les packages_fichiers/cpan.jpg" 
      width=141></TD></TR></TBODY></TABLE>
<H3>La procédure d'installation est détaillée dans : <A 
href="http://www.cpan.org/modules/INSTALL.html">http://www.cpan.org/modules/INSTALL.html</A> 
</H3>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/References.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, les packages_fichiers/prec.gif"> 
</A>Précédent </DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Tk.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, les packages_fichiers/suiv.gif"> 
</A></DIV></H2></BODY></HTML>
