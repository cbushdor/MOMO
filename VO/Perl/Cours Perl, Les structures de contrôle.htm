<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0053)http://www.dil.univ-mrs.fr/~chris/Perl/Structctrl.htm -->
<HTML><HEAD><TITLE>Cours Perl, Les structures de contrôle.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, Les structures de contrôle_fichiers/Messtyles.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Les structures de contrôle.</H1>
<H2>L'opérateur do.</H2>
<H3>Cet opérateur permet d'effectuer une boucle en reportanten le test de sortie 
de la boucle à la fin du bloc. Ainsi la boucle sera toujours éxécutée au moins 
une fois. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>do {
  Instruction 1;
  Instruction 2;
  . . . .;
  Instruction n;
}
until (condition);
  </PRE></DIV></DIV>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>do {
  Instruction 1;
  Instruction 2;
  . . . .;
  Instruction n;
}
while (condition);
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme do1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$compt = 0;
do {
  print ("Valeur du compteur $compt.\n");
  $compt++;
}
until ($compt eq 5);
print ("Fin du programme.\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl do1.pl<SPAN class=rouge>ent</SPAN>
Valeur du compteur 0.
Valeur du compteur 1.
Valeur du compteur 2.
Valeur du compteur 3.
Valeur du compteur 4.
Fin du programme.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme do2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$compt = 0;
do {
  print ("Valeur du compteur $compt.\n");
  $compt++;
}
while ($compt le 5);
print ("Fin du programme.\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl do2.pl<SPAN class=rouge>ent</SPAN>
Valeur du compteur 0.
Valeur du compteur 1.
Valeur du compteur 2.
Valeur du compteur 3.
Valeur du compteur 4.
Valeur du compteur 5. 
Fin du programme.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>L'opérateur last.</H2>
<H3>Il permet de terminer l'exécution d'une boucle et de continuer l'exécution 
avec la première instruction qui suit le bloc.<BR>Cette instruction n'affecte 
que les blocs de boucles (for, foreach, while), elle n'a aucune action sur les 
blocs n'appartenant pas a une itération (if par exemple). </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>while (cond1) {
  instruction_w1;
  instruction_w2;
  if (cond2) {
    instruction_i1;
    instruction_i2;
    last;
  }
  instruction_w3;
  instruction_w4;
}
# last vient ici.
instruction;
  </PRE></DIV></DIV>
<H3>Dans l'exemple ci dessus, le last est inclus dans un bloc sur lequel il n'a 
aucun effet (if)<BR>Par contre, ce bloc if est lui même inclus dans un bloc 
while. C'est donc sur ce dernier qu'il portera son action. </H3>
<H2>L'opérateur next.</H2>
<H3>Il permet de sauter la partie non encore exécutée d'une boucle et de passer 
à l'itération suivant sans terminer l'exécution du bloc.<BR>Comme dans le cas du 
last; l'instruction next n'affecte que les blocs de boucles (for, foreach, 
while) et n'a aucune action sur les blocs n'appartenant pas a une itération (if 
par exemple). </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>while (cond1) {
  instruction_w1;
  instruction_w2;
  if (cond2) {
    instruction_i1;
    instruction_i2;
    next;
  }
  instruction_w3;
  instruction_w4;
  # next vient ici.
}

instruction;
  </PRE></DIV></DIV>
<H3>Dans l'exemple ci dessus, le last est inclus dans un bloc sur lequel il n'a 
aucun effet (if) <BR>Par contre, ce bloc if est lui même inclus dans un bloc 
while. C'est donc sur ce dernier qu'il portera son action. </H3>
<H2>L'opérateur redo.</H2>
<H3>Ce troisième opérateur de contrôle va permettre la rééxécution du bloc 
courant à son début, sans que l'expression de contrôle ne soit 
réévaluée.<BR>Comme dans le cas du last; l'instruction redo n'affecte que les 
blocs de boucles (for, foreach, while) et n'a aucune action sur les blocs 
n'appartenant pas a une itération (if par exemple). </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>while (cond1) {
  # redo vient ici.
  instruction_w1;
  instruction_w2;
  if (cond2) {
    instruction_i1;
    instruction_i2;
    redo;
  }
  instruction_w3;
  instruction_w4;
}
instruction;
  </PRE></DIV></DIV>
<H3>Dans l'exemple ci dessus, le last est inclus dans un bloc sur lequel il n'a 
aucun effet (if) <BR>Par contre, ce bloc if est lui même inclus dans un bloc 
while. C'est donc sur ce dernier qu'il portera son action. </H3>
<H2>Les blocs étiquetés.</H2>
<H3>Cette propriété va permettre d'identifier un bloc auquel on pourra faire 
référence par l'intermédiaire des opérateurs que l'on vient de définir (last, 
next et redo).<BR>Un label se reconnait du fait que son nom n'est pas précédé 
d'un caractère spécial (@,$,%) comme c'est le cas pour les variables ordinaires. 
</H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>LABEL: while (quelque_chose) {
  instruction_w1;
  instruction_w2;
    if (condition) {
      instruction_i1;
      instruction_i2;
      last LABEL;
    }
}
instruction;
  </PRE></DIV></DIV>
<H3>On cherche par exemple tous les couples de nombres dont le produit est égal 
à une certaine valeur. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme lab.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$v = 36;
EXTERNE: for ($i = 1;$i &lt;= 10; $i++) {
  INTERNE: for ($j = 1;$j &lt;= 10; $j++) {
    if ($i * $j == $v) {
      print "$v = $i * $j\n";
      next EXTERNE;
    }
    if ($j &gt;= $i) {
      last INTERNE;
    }
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl lab.pl<SPAN class=rouge>ent</SPAN>
36 = 6 * 6
36 = 9 * 4
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Les modificateurs d'expression.</H2>
<H3>La syntaxe Perl propose une autre manière d'effectuer un choix conditionnel 
qui s'écrit plus naturellement que : </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>if (condition){
  instruction
}
  </PRE></DIV></DIV>
<H3>Cette instruction peut aussi s'écrire sous la forme : </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>instruction if (condition);
  </PRE></DIV></DIV>
<H3>Qui permet d'évaluer tout d'abord la valeur de la condition et, si le 
résultat de cette évaluation donne le résultat 'vrai' alors l'instruction est 
évaluée à son tour.<BR>Dans le même ordre d'idées, on pourra écrire les 
modificateurs : </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>instruction unless (condition);
instruction while (condition);
instruction until (condition);
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme lister.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
while (1){
last if ($ligne = &lt;&gt;);
print("$ligne");
};
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl lister.pl ent.txt<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier ent.txt
Ligne 2 du fichier ent.txt
Ligne 3 du fichier ent.txt
Ligne 4 du fichier ent.txt
Ligne 5 du fichier ent.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment><PRE>open (ENTREE, "donnees.txt");
while($a = <ENTREE>){
  last LIGNE if ($a eq "fin")
  print;
}
close(ENTREE);
    </PRE></TD>
    <TD class=comment>On liste un fichier. On doit stoper soit si on arrive au 
      bout du fichier, soit si la ligne qui vient d'être lue contient la chaîne 
      de caractères "fin".<BR>Il n'était pas indispensable d'étiqueter le bloc. 
    </TD></TR></TBODY></TABLE>
<H2>L'évaluation en court circuit.</H2>
<H3>les expressions logiques utilisent les opérateurs classiques. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>Union </TD>
    <TD>|| </TD>
    <TD>or </TD></TR>
  <TR>
    <TD>Intersection </TD>
    <TD>&amp;&amp; </TD>
    <TD>and </TD></TR>
  <TR>
    <TD>Complémentation </TD>
    <TD>! </TD>
    <TD>not </TD></TR></TBODY></TABLE>
<H3>Evaluer une expression 'en court circuit' signifie que l'on cessera le 
calcul dés que l'on sera certain du résultat.<BR>Par exemple, si nous avons 
l'expression logique suivante : 
<H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>$et = $a and $b;
  </PRE></DIV></DIV>
<H3>Si $a est évalué a 'vrai', le résultat final dépendra de l'évaluation de 
$b.<BR>Si $a est évalué à 'faux', il n'est pas nécessaire de procéder à 
l'évaluation de $b pour savoir que le résultat final sera faux. </H3>
<H3>De la même mamière, pour l'expression. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>$ou = $a or $b;
  </PRE></DIV></DIV>
<H3>Si $a est évalué a 'faux', le résultat final dépendra de l'évaluation de 
$b.<BR>Si $a est évalué à 'vrai', il n'est pas nécessaire de procéder à 
l'évaluation de $b pour savoir que le résultat final sera vrai. </H3>
<H3>Or, comme nous avons déjà évoqué, en perl tout est évaluable. Toute 
fonction, toute expression est considérée comme apte à retourner un résultat 
utilisable dans une expression logique.<BR>Le seul moyen de retourner un 
résultat est, bien entendu de procéder à l'exécution de l'instruction. </H3>
<H3>C'est ainsi que l'on peut écrire : </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>instruction1 and instruction2;
  </PRE></DIV></DIV>
<H3>L'opération qui est demandée étant une opération logique, le résultat de 
l'évaluation de chacon des opérateurs sera automatiquement converti en 
(vrai/faux).<BR>Dans un premier temps, il est procédé à l'évaluation de 
"instruction1".<BR>Si le résultat de la conversion donne la valeur logique 
'vrai', alors pour pouvoir fournir un résultat, il est indispensable de procéder 
à l'évaluation de "instruction2" donc d'exécuter cette instruction.<BR>Dans le 
cas contraire, si le résultat de la conversion donne la valeur logique "faux" il 
n'est pas nécessaire de continuer le calcul pour connaitre le résultat final. 
"instruction2" n'ayant pas à être évaluée, elle ne sera pas exécutée. </H3>
<H3>Un raisonnement identique permet de comprendre comment se passerait 
l'évaluation de. </H3>
<DIV class=centre style="WIDTH: 17em">
<DIV class=prog><PRE>instruction1 or instruction2;
  </PRE></DIV></DIV>
<TABLE width="58%" align=center border=2>
  <TBODY>
  <TR>
    <TH>La condition</TH>
    <TH>Peut se réécrire</TH></TR>
  <TR>
    <TD>if (cond) {instruction};</TD>
    <TD>cond and instruction;</TD></TR>
  <TR>
    <TD>unless (cond) {instruction};</TD>
    <TD>cond or instruction</TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme impairs.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
# Lister les nombres impairs
# compris entre 1 et 10
for ($i=1;$i&lt;=10;$i++){
  ($i%2) and print ("$i\n");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl impairs.pl<SPAN class=rouge>ent</SPAN>
1
3
5
7
9
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme pairs.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
# Lister les nombres pairs
# compris entre 1 et 10
for ($i=1;$i&lt;=10;$i++){
($i%2) or print ("$i\n");
};
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl pairs.pl<SPAN class=rouge>ent</SPAN>
2
4
6
8
10
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>L'opérateur ?: .</H2>
<H3>C'est l'opérateur ternaire conditionnel. On peut, en première approximation 
considérer qu'il fonctionne comme une instruction if/then/else, mais en plus, il 
peut être dans n'importe quelle instruction ou opération.<BR>son fonctionnement 
peut être résumé comme suit. </H3>
<DIV class=centre style="WIDTH: 27em">
<DIV class=prog><PRE>Condition ? Expression-vraie : expression-fausse;
  </PRE></DIV></DIV>
<H3>La condition est évaluée.<BR>Si le résultat de cette évaluation est "vrai" 
alors seulement Expression-vraie sera évaluée.<BR>Si le résultat de cette 
évaluation est "faux" alors seulement Expression-fausse sera évaluée. <BR>Dans 
tous les cas, le résultat de l'évaluation qui aure été faite deviendra la valeur 
de l'expression. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme quest.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
print ("Quel est ton prenom ? ");
chomp($prenom = <STDIN>);
$sexe = $prenom == "Roger ? "Monsieur : "Madame";
print ("Bonjour $sexe $prenom Rabbit.\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl quest.pl<SPAN class=rouge>ent</SPAN>
Quel est ton prénom ? Roger<SPAN class=rouge>ent</SPAN>
Bonjour Monsieur Roger Rabbit.
c:\prog&gt; perl quest.pl<SPAN class=rouge>ent</SPAN>
Quel est ton prénom ? Jessica<SPAN class=rouge>ent</SPAN>
Bonjour Madame Jessica Rabbit.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Programmes distrayants.</H2>
<H3>Pour nous distraire un peu, voyons comment nous pouvons décliner un même 
programme sous différentes présentations. </H3>
<H3>Soit à compter le nombre de lignes d'un fichier. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme cpt1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
for (;&lt;&gt;;$i++){};

print ("Le fichier $ARGV[0]\n");
print ("comporte $i lignes.\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl cpt1.pl texte.txt<SPAN class=rouge>ent</SPAN>
Le fichier texte.txt
comporte 100 lignes.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme cpt2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
1 while &lt;&gt;;

print ("Le fichier $ARGV[0]\n");
print ("comporte $. lignes.\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl cpt2.pl texte.txt<SPAN class=rouge>ent</SPAN>
Le fichier texte.txt
comporte 100 lignes.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Explication : $. est la variable prédéfinie contenant le numéro de la ligne 
courante du fichier. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme cpt3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
while (1) {
  (&lt;&gt; &amp;&amp; $i++) || last;
}

print ("Le fichier $ARGV[0]\n");
print ("comporte $i lignes.\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl cpt3.pl texte.txt<SPAN class=rouge>ent</SPAN>
Le fichier texte.txt
comporte 100 lignes.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Soit à affecter une valeur à une variable en fonction du résultat d'un 
test.<BR>La variable $y doit se voir affecter la valeur 500 si la condition $x 
est remplie ($x = 1), ou la valeur 100 si la condition $x n'est pas remplie ($x 
= 0). </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment>Dans le style programmation classique. </TD>
    <TD class=comment>if ($x == 0) {$y = 10;} else {$y = 20;} </TD></TR>
  <TR>
    <TD class=comment>Même chose, un peu plus réfléchi. </TD>
    <TD class=comment>if ($x) {$y=20} else {$y=10} </TD></TR>
  <TR>
    <TD class=comment>En inversant le test. </TD>
    <TD class=comment>unless ($x == 0) {$y=20} else {$y=10} </TD></TR>
  <TR>
    <TD class=comment>En utilisant le modificateur. </TD>
    <TD class=comment>$y = 20; $y = 10 if $x==0; </TD></TR>
  <TR>
    <TD class=comment>Au moyen de l'opérateur ternaire. </TD>
    <TD class=comment>$y = $x==0 ? 10 : 20; </TD></TR>
  <TR>
    <TD class=comment>Beaucoup plus amusant. </TD>
    <TD class=comment>$y = (10,20)[$x != 0]; </TD></TR></TBODY></TABLE>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Controle.htm"><IMG 
style="VERTICAL-ALIGN: middle" 
src="Cours Perl, Les structures de contrôle_fichiers/prec.gif"> </A>Précédent 
</DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Hash.htm"><IMG 
style="VERTICAL-ALIGN: middle" 
src="Cours Perl, Les structures de contrôle_fichiers/suiv.gif"> 
</A></DIV></H2></H3></H3></BODY></HTML>
