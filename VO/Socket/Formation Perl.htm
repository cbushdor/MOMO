<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0069)http://www.ac-creteil.fr/util/programmation/perl/cours/tp-reseau.html -->
<HTML><HEAD><TITLE>Formation Perl</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="Jean Gourdin" name=Author>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY bgColor=white><A 
href="http://www.ac-creteil.fr/util/programmation/perl/welcome.html"><IMG 
height=97 src="Formation Perl_fichiers/logoPerl.gif" width=97 align=left 
border=0></A> 
<DIV align=center>
<H1>TP Programmation réseau</H1></DIV>
<P>
<HR width="85%" noShade SIZE=3>
<BR clear=left>
<H3>Envoi de mails</H3>Vérifier (avec la commande whereis sendmail) que votre 
machine comporte bien le MTA (=mail transport agent) <B>sendmail</B>. Si c'est 
le cas, on peut alors l'utiliser dans un script comme agent d'expédition en 
adressant sur son entrée standard une chaine correcte.<BR>Rien de plus facile 
que d'envoyer des messages ! Pour cela il suffit d'ouvrir un fichier en écriture 
vers sendmail à travers un pipe. Bien respecter le format, contraignant, du 
courrier !<BR>Voici un exemple à adapter et à tester : <PRE>#!/usr/bin/perl

print "Essai d'envois de mails\n";
$destinataire="nom <XXX.YYY\@DOMAINE.FR>";
$nom = $destinataire;
$nom =~ s/^\s*(\w+)\s+&lt;.*$/$1/;
$expediteur="....";
$repondre="....";

# option -t pour que sendmail intégre les en-têtes fournies
open(MAIL,"|/usr/lib/sendmail -t") or die "impossible 
d'expédier par sendmail !";

# attention : bien observer la syntaxe de cette chaine
# un <B>seul</B> passage à la ligne (ou \n) entre chaque en-tete
# un : après chaque mot-clé
$message="From: $expediteur
To: $destinataire\nReply-To: $repondre
Subject: Salut !
Bonjour $nom
Le stage n'est pas trop dur ?
Comment vas-tu aujourd'hui ?

xxx";
print MAIL $message;
close MAIL;
</PRE>
<H3>Exemple de session FTP </H3>Avec le module <B>Net::FTP</B>, on dispose avec 
une notation orientée-objet de fonctions de base permettant d'ouvrir une 
connexion FTP dans un programme Perl et d'y travailler de la meme façon qu'avec 
un client<BR>Voici un script sommaire, permettant de récupérer la page 
<I>ftp://ftp.cpan.org/pub/CPAN/CPAN.html</I> <PRE>#!/usr/bin/perl -w
use Net::FTP;
# tenter une connexion, et obtenir un identifiant de connexion
# dans le jargon objet, il s'agit de la construction d'un objet noté ici $ftp
# tant que la session reste ouverte, on adresse des méthodes à cet objet : login,cwd,get,put ..
# documentation à consulter : <B>perldoc Net::FTP</B>
#####################################################
$ftp = Net::FTP -&gt; new (
 "ftp.cpan.org",
  Passive =&gt;1 )
  Timeout =&gt; 30
  ) or die "Connexion impossible\n";
$ftp-&gt; login("anonymous","jean") or die "connexion impossible";
$ftp-&gt; cwd('/pub/CPAN');
$fichier= "CPAN.html";
$local = "cpan.html";
$ftp-&gt; get($fichier, $local) or die "Impossible d'obtenir $fichier !";
# on obtient la page d'accueil : <I>http://www.cpan.org/CPAN.html</I>
</PRE>
<H3>Introduction aux sockets</H3>Il ne s'agit ici que d'une brève introduction, 
en grande partie issue de l'indispensable référence : 
<BR><I>http://www.enstimac.fr/Perl/DocFr/perlipc.html</I> 
<UL>
  <LI>Les sockets sont les canaux de communications (type principaux streams et 
  datagrammes). Ils "se branchent" à un hote identifié par son adresse IP et à 
  un port. Deux machines voulant échanger sur le réseau doivent de plus choisir 
  un protocole de communication, compatible avec le type de socket.<BR>Des 
  modules spécialisés Perl existent heureusement déjà pour faciliter le dialogue 
  client-serveur en respectant le protocole, et portent des noms comme Net::FTP 
  <LI>Dialogue client-serveur<BR>Le serveur doit être en exécution et "écoute" 
  sur un port, en attente du client.<BR>Un processus qui se positionne comme 
  client d'un service d'un serveur distant, doit : 
  <OL>
    <LI>s'adresser d'abord à la bonne machine sur le réseau (local ou Internet), 
    et pour cela fournir son numéro IP directement, par exemple 66.35.250.175 
    (ou en utilisant un service DNS pour l'obtenir à partir de son nom public de 
    serveur, par exemple <I>use.perl.org</I> (devinez qui s'est installé à 
    www.perl.fr/) 
    <LI>s'adresser au bon service en indiquant son <I>port</I>, numéro qui 
    identifie ce service. L'attribution des numéros de port est standardisé (de 
    0 à 65535). Sur une machine Unix, consulter le fichier <I>/etc/services</I> 
    qui est une table de correspondance (HTTP : 80, FTP : 21 ..) 
    <LI>créer une <I>socket</I>, un support de communication en direction de ce 
    service, dans le but d'échanger des données 
    <LI>si la socket est créée, la connexion acceptée par le serveur, celui-ci 
    renvoie une valeur scalaire semblable à un descripteur de fichier (ou plutot 
    de flux). Muni de cette référence le client pourra dialoguer avec le 
    serveur, à la fois en lecture et en écriture. 
    <LI>Bien entendu par la suite il faut utiliser le langage de commande du 
    service connecté, par exemple envoyer une chaine commençant par la commande 
    GET pour une requete HTTP, comme le ferait un client HTTP, un navigateur. 
    </LI></OL>
  <LI>En mode interactif, la socket du client se met généralement à l'écoute du 
  serveur, de façon semblable à l'attente d'une saisie clavier vis à vis de 
  l'entrée standard &lt;STDIN&gt;. Si le descripteur de socket s'appelle 
  <I>$sock</I>, le processus devra s'exécuter dans une boucle du genre 
  :<BR><B>while ($ligne= &lt;$sock&gt; ) { ....}</B>. <BR>Il faut dans ces 
  conditions faire appel à un autre processus pour pouvoir écrire en meme temps 
  <LI>La présentation qui suit n'utilise pas le module de base <B>Socket</B>, 
  qui prend appuie directement sur les fonctions C, mais un module 
  orienté-objet, de plus haut niveau pour le programmeur<BR>Cette classe 
  <B>IO::Socket</B> permet aisément de construire un objet "socket". Il faut 
  passer les caractéristiques du service à connecter au constructeur de socket 
  <B>new </B>de cette classe pour récupérer un "handle de socket". Celui-ci 
  identifie la connexion et est manipulé au point de vue langage comme un 
  descripteur de fichier . 
  <LI>Paramètres principaux : 
  <UL>
    <LI><B>Proto</B> : le protocole TCP ou UDP 
    <LI><B>PeerAddr</B> : nom (ou adresse IP) du serveur (les requêtes DNS 
    éventuelles sont transparentes) 
    <LI><B>PeerPor</B>t : nom du service (/etc/services est alors interrogé) ou 
    numéro du port 
    <LI><B>LocalPort</B> : nom du service ou le numéro du port sur le serveur 
    (sous Unix, les ports en dessous de 1024 sont réservés à root). 
    <LI><B>Reuse</B> : paramètre nécessaire pour pouvoir redémarrer le serveur 
    manuellement ? 
    <LI><B>Listen </B>: nombre maximal de connexion acceptables avant de rejeter 
    les clients arrivants. </LI></UL></LI></UL>
<H3><IMG height=33 src="Formation Perl_fichiers/ordi.gif" width=39 
border=0>&nbsp;&nbsp;TP </H3>
<H4>################ daytime.pl : <I>client du service daytime</I> 
############</H4>
<UL>
  <LI>Il s'agit de créer un client qui se connecte sur le port 13 d'un serveur 
  <B>daytime</B> (vérifier si nécessaire le paramétrage du service dans son 
  fichier de configuration <I>/etc/xinetd.d/daytime</I>) 
  <LI>Ce serveur interrogé se contente de répondre au client en lui envoyant le 
  jour et l'heure de son système, tel qu'on peut les obtenir directement par le 
  truchement de la commande date. 
  <LI>Ici le client va se contenter d'afficher cette information, mais cela 
  pourrait faire l'objet d'un traitement, comme la synchronisation de l'horloge 
  du client sur celle du serveur. 
  <LI>Vérifier que le module <B>IO::Socket</B> est bien installé sur votre 
  machine en ligne de commande 
  <LI>Tester ce script sur localhost, puis sur un serveur distant sur lequel 
  vous vérifierez la date système <PRE>#!/usr/bin/perl -w
# appel : daytime.pl adresse-ip

use IO::Socket;
print "adresse IP du serveur (ou valider sur localhost) : ";
$adresse = &lt;&gt;;
chomp $adresse;
$adresse= "localhost" if $adresse eq "";
$socket = IO::Socket::INET-&gt;new(
	Proto =&gt; "tcp",
	PeerAddr =&gt; $adresse,
	PeerPort =&gt; "daytime(13)"
	)
  or die "connexion impossible au service daytime sur $adresse";

print "Voici le jour et l'heure sur $adresse\n";
while ( &lt;$socket&gt; ) {
 print;
}
</PRE></LI></UL>
<H4>###################### navig.pl : <I>mini client HTTP</I> 
#######################</H4>Il s'agit de se connecter à un serveur WEB (port 80) 
dont l'adresse est demandée (ou bien passé en paramètre) et d'obtenir la page 
d'accueil du serveur WEB. En particulier on expérimente le comportement 
bidirectionnelle de la socket : le client émet l'instruction HTTP puis se met à 
l'écoute.<BR><U>Remarques </U>: 
<OL>
  <LI>l'adresse du document doit être absolue par rapport à la racine du web, 
  par exemple /index.html (ne pas oublier le /) 
  <LI>la commande à adresser au serveur est "GET $document HTTP/1.0\n\n", 
  conformément au protocole HTTP 
  <LI>Compléter le source. Tester d'abord en demandant la page d'accueil du 
  serveur apache de la machine voisine 
  <LI>modifier le programme pour enregistrer sur disque la page d'accueil de 
  Créteil (si vous voulez l'ip :<I> nslookup www.ac-creteil.fr</I>) 
</LI></OL><U>Prolongement</U><BR>Ecrire maintenant <B>webget.pl</B>, à partir de 
navig.pl, permettant d'enregistrer localement dans le répertoire personnel, les 
pages dont les adresses auront été obtenues soit par dialogue, soit par passage 
de paramètre sur la ligne de commande. <PRE>#!/usr/bin/perl -w
# appel : navig.pl adresse-ip
#############################
use IO::Socket;
print "nom ou adresse IP du serveur WEB (par défaut créteil) : ";
$web = &lt;&gt;; chomp($web);
$web= "www.ac-creteil.fr" if $web eq "";
print "Document (par défaut ..) : ";
$doc = &lt;&gt;; chomp($doc);
$doc= "/util/programmation/perl/cours/tp-introduction.html" if $doc eq "";

$sock = IO::Socket::INET-&gt;new(
	...........
	..........,
	...........
	)
  or die "connexion impossible au port 80 sur $web";
$sock -&gt; autoflush(1);
# envoi, par socket, de la requete HTTP habituellement envoyée par le navigateur
print $sock "GET $doc HTTP/1.0\n\n";
print "Voici le document $doc sur $web\n";
while ( &lt;$socket&gt; ) {
 print;
}
</PRE>
<H4>################ Programmer un dialogue interactif client-serveur 
###############</H4>
<UL>
  <LI>Voici un code de base s'appuyant sur le module <I>IO::Socket</I>, pour 
  créer à l'exécution des processus serveur et client qui pourront dialoguer. 
  <LI>Problème : comment gérer l'interactivité de façon générale ? en effet si 
  les processus serveurs et clients sont en écoute permanente avec une 
  instruction comme <B>$ligne = &lt;$socket&gt;</B>, ils demeurent bloqués 
  jusqu'à la réception d'une ligne et ils ne peuvent pas "s'écrire". La solution 
  consiste à cloner chaque processus avec <B>fork</B> et à spécialiser chacun 
  des processus soit dans la réception, soit dans l'émission. 
  <LI>L'appel fork crée, on l'a vu, un processus fils qui exécute le meme code 
  que son père après sa création. Le script doit dès lors tester la variable 
  $pid renvoyée par fork, ce qui permet de différencier le code (réception ou 
  émission) en fonction du processus auquel il s'adresse. 
  <LI>Etudier les codes commentés, serveur et client. Puis récupérer les 2 
  scripts <I>serveur.pl</I> et <I>client.pl</I>, et les adapter éventuellement 
  pour les faire communiquer sur 2 machines différentes.<BR>Sur Unix, utiliser 
  <I>netstat -at</I> pour connaitre les serveurs actifs. 
  <LI><U>Code serveur commenté</U> <PRE>#!/usr/bin/perl -w
# serveur.pl  #
###############
use IO::Socket;

$server = IO::Socket::INET-&gt;new(
    LocalPort =&gt; 1234,
    Type      =&gt; SOCK_STREAM,
    Reuse     =&gt; 1,
    Listen    =&gt; 5
) or die "Création du serveur impossible.\n";
print "Démarrage du serveur ..\n";

while ($client = $server-&gt;accept()) {
 print $client "Le serveur dit 'bonjour' au client !\n";

 $pid = fork;
 die "Je ne peux pas forker !" if ! defined ($pid);

 if ($pid ==0) {
 # c'est le processus enfant, chargé de l'écoute des clients
 #############################################################
   while ($ligne = &lt;$client&gt; ) {
     print "client&gt; $ligne";

   }
  } else {
  # c'est le père qui pendant ce temps répond au client #
  #######################################################
   while ($ligne = &lt;&gt;) {
     print $client $ligne;
  }
 }
}
</PRE>
  <LI><U>Code client commenté</U> <PRE>#!/usr/bin/perl -w
# client.pl  #
##############
use IO::Socket;

print "nom ou adresse IP du serveur (localhost par défaut) ";
$adresse = &lt;&gt;; chomp($adresse);
$adresse= "localhost" if $adresse eq "";

$socket = IO::Socket::INET-&gt;new(
        PeerAddr =&gt; $adresse,
        Proto =&gt; "tcp",
        PeerPort =&gt; 1234
        )
or die "Connexion au serveur impossible.\n";

$pid = fork;
die "Je ne peux pas forker !" if ! defined ($pid);

if ($pid ==0) {
 # c'est le processus enfant, chargé de l'émission au serveur
 #############################################################
    while ($ligne = &lt;&gt; ) {
     print $socket $ligne;
    }
} else {
  # c'est le père qui pendant ce temps écoute le serveur
  #######################################################
    while ($ligne = &lt;$socket&gt;) {
     print "serveur&gt; $ligne";
    }
}
</PRE></LI></UL></BODY></HTML>
