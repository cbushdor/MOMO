<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://www.dil.univ-mrs.fr/~chris/Perl/Controle.htm -->
<HTML><HEAD><TITLE>Cours Perl, Les instructions de contrôle.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, Les instructions de contrôle_fichiers/Messtyles.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Les instructions de contrôle.</H1>
<H3>Nous avons déjà vu quelques notions de base que nous allons rappeler 
rapidement. </H3>
<H2>La notion de bloc.</H2>
<H3>En Perl, toute instruction doit impérativement se terminer par un ; (point 
virgule).<BR>Un bloc sera une suite d'instructions encadré par des accolades. 
</H3>
<DIV class=centre>
<DIV class=prog><PRE>{
  Instruction 1;
  Instruction 2;
  . . . .;
  Instruction n;
}
  </PRE></DIV></DIV>
<H3>Les instructions sont éxécutées dans l'ordre de la première à 
dernière<BR>Syntaxiquement un bloc d'instructions peut être placé n'importe où 
dans le programme.. </H3>
<H2>L'instruction conditionnelle.</H2>
<H3>Ce sont les instructions "if/then/else" et "unless". </H3>
<DIV class=centre>
<DIV class=prog><PRE>if expression) {
  instruction-vraie_1;
  instruction-vraie_2;
  instruction-vraie_3;
} else {
  instruction-fausse_1;
  instruction-fausse_2;
  instruction-fausse_3;&lt;
}
  </PRE></DIV></DIV>
<DIV class=centre>
<DIV class=prog><PRE>unless (expression) {
  instruction-fausse_1;
  instruction-fausse_2;
  instruction-fausse_3;
}
  </PRE></DIV></DIV>
<H3>La règle d'évaluation de l'expression est la suivante :<BR>L'expression est 
évaluée comme une chaîne de caractères.<BR>C'est une chaîne, elle ne sera pas 
modifiée.<BR>C'est une valeur numérique, elle sera convertie en une chaîne de 
caractèress.<BR>Si la chaîne obtenue est vide ("") ou ne contient que le 
caractère 0 ("0") alors la valeur de l'expression est "faux".<BR>Par définition 
pour toute autre chaîne la valeur de l'expression est "vrai". </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>La valeur :</TH>
    <TH>Convertie en :</TH>
    <TH>Donne le résultat :</TH></TR>
  <TR>
    <TD>0</TD>
    <TD>"0"</TD>
    <TD>faux</TD></TR>
  <TR>
    <TD>1-1 = 0</TD>
    <TD>"0"</TD>
    <TD>faux</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>"1"</TD>
    <TD>vrai</TD></TR>
  <TR>
    <TD>""</TD>
    <TD>n'est pas convertie</TD>
    <TD>faux</TD></TR>
  <TR>
    <TD>"1"</TD>
    <TD>n'est pas convertie</TD>
    <TD>vrai</TD></TR>
  <TR>
    <TD>"0"</TD>
    <TD>n'est pas convertie</TD>
    <TD>faux</TD></TR>
  <TR>
    <TD>"00"</TD>
    <TD>n'est pas convertie</TD>
    <TD>vrai</TD></TR>
  <TR>
    <TD>"0.00"</TD>
    <TD>n'est pas convertie</TD>
    <TD>vrai</TD></TR>
  <TR>
    <TD>"undef</TD>
    <TD>""</TD>
    <TD>faux</TD></TR></TBODY></TABLE>
<H3>En certaines ocasions, il est possible de se trouver dans une situation ou 
plus de deux choix sont possibles. On dispose alors d'une conditionnelle "elsif" 
pour gérer les autres choix. </H3>
<DIV class=centre>
<DIV class=prog><PRE>if(exp1) {
  # exp1-vraie;
} elsif (exp2){
  # exp2-vraie;
} elsif (exp3){
  # exp3-vraie;
} else {
  # Toutes-exp-fauses
}
  </PRE></DIV></DIV>
<H2>L'instruction répétitive.</H2>
<H3>Ce sont les instructions "while" et "until". </H3>
<DIV class=centre>
<DIV class=prog><PRE>while (expression) {
  instruction_1;
  instruction_2;
  instruction_3;
}
  </PRE></DIV></DIV>
<H3>Règle d'évaluation de l'expression.<BR>Si le résultat est "vrai" alors le 
corps du while est exécuté une fois, cette opération est ensuite répétée jusqu'à 
ce que l'expression prenne la valeur "faux".Le contrôle passe alors à 
l'instruction qui suit le corps du while. </H3>
<DIV class=centre>
<DIV class=prog><PRE>until (expression) {
  instruction_1;
  instruction_2;
  instruction_3;
}
  </PRE></DIV></DIV>
<H3>R?e d'?luation de l'expression.<BR>Si le résultat est "faux" alors le corps 
du until est exécuté une fois, cette opération est ensuite répétée jusqu'à ce 
que l'expression prenne la valeur "vrai".Le contrôle passe alors à l'instruction 
qui suit le corps du until. </H3>
<H2>La boucle for.</H2>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>for (initial;test;increment) {
  instruction_1;
  instruction_2;
  instruction_3;
}
  </PRE></DIV></DIV>
<H3>Le fonctionnement de la boucle est le suivant : </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>1</TD>
    <TD>Evaluation de l'expression "initial".<BR>Cette expression est 
      généralement une affectation initiale à une variable d'itération.<BR>Il 
      n'y a toutefois aucune restriction sur son contenu. </TD></TR>
  <TR>
    <TD>2</TD>
    <TD>Evaluation de l'expression "test" procurant un résultat "vrai" ou 
      "faux. </TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD>Si le résultat de l'évaluation est "vrai", le corps de l'itération est 
      exécuté suivi de l'evaluation de l'expression "increment" (généralement 
      une opération sur la variable d'incrément), puis retour en 2. </TD>
    <TD>Si le résultat est "faux" alors on passe à l'instruction qui suit le 
      bloc d'itération. </TD></TR></TBODY></TABLE>
<H2>L'instruction print.</H2>
<H3>Cette instruction va nous permettre de présenter les résultats.<BR>Sa forme 
générale est : </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog>print ("chaine de caracteres"); </DIV></DIV>
<H3>Ainsi que nous le verrons ultérieurement dans le chapitre consacré aux 
chaînes de caractères, cette dernière peut être contenue dans une variable ou 
désinie explicitement. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog>print ("Bonjour tout le monde."); </DIV></DIV>
<H3>Va permettre d'afficher sur l'écran le message en question. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog>Bonjour tout le monde. </DIV></DIV>
<H3>La présentation de résultats se fera aussi de manière simple.. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog>$a = 10;<BR>$b = 5;<BR>$c = $a * *b;<BR>print ("Le produit de $a 
par $b\n");<BR>print ("est egal a $c/n"); </DIV></DIV>
<H3>Donnera : </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog>Le produit de 10 par 5<BR>est egal a 50 </DIV></DIV>
<H2>Les gestionnaires de fichiers.</H2>
<H3>Les gestionnaires de fichiers vont permettre au programmeur d'échanger des 
données avec le monde extérieur.<BR>Nous avons déjà travaillé suur un 
gestionnaire de fichier implicite &lt;STDIN&gt;.<BR>Il existe aussi comme pour 
Unix.<BR>&lt;STDOUT&gt; : Le descripteur du fichier standard de sortie 
(généralement, l'écran).<BR>&lt;STDERR&gt; : Le descripteur du fichier standard 
d'erreur (le même que &lt;STDOUT&gt;).<BR>Afin de bien différencier un 
descripteur de fichier des autres références, il est de tradition d'utiliser des 
majuscules pour les représenter. </H3>
<H2>Rappels sur la ligne de commande .</H2>
<H3>Nous avons déjà expliqué comment un programme était soumis à l'interpréteur. 
Voyons un peu plus en détait comment se présente la ligne de commande. Elle 
peut, comporter une liste d'appel : </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog>c:\prog perl appli.pl fichier1.txt fichier2.txt </DIV></DIV>
<H3>Nous retrouvons la requète à l'interpréteur (perl)<BR>Le fichier qui lui est 
soumis (appli.pl)<BR>Puis une liste de paramètres (ici, des noms de 
fichiers).<BR>Ces noms seront stockés par le système d'exploitation dans une 
liste spécifique dont le nom a été prédéfini (@ARGV) en majuscules.<BR>En fait, 
le programme qui est appelé (appli.pl) dispose de la liste @ARGV dans laquelle 
il disposera des informations suivantes : </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>$ARGV[0]</TD>
    <TD>"fichier1.txt"</TD></TR>
  <TR>
    <TD>$ARGV[1]</TD>
    <TD>"fichier2.txt"</TD></TR></TBODY></TABLE>
<H3>Stockées sous forme de chaînes de caractères. </H3>
<H2>L'opérateur Diamand (Diamond operator).</H2>
<H3>C'est la manière la plus simple pour accéder, en lecture, à un fichier (ou a 
une série de fichiers).<BR>Le nom du fichier concerné doit être stocké dans la 
liste spéciale prédéfinie @ARGV.<BR>Cette opération peut se faire au moyen d'une 
affectation.<BR>@ARGV = ("monfichier.txt","donnees.txt","valeurs.txt"); Ou bien 
en utilisant la liste d'appel de la ligne de commande comme indiqué au 
paragraphe précédent.<BR>Si la liste contient plusieurs fichiers, on accèdera 
ligne par ligne au premier jusqu'à la fin, puis on passera au suivant et ainsi 
de suite.<BR>Le descripteur de l'opérateur diamand est &lt;&gt; (d'où son nom) 
</H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme liste1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>@ARGV = ("entree.txt");
while ($ligne = &lt;&gt;){
  print("$ligne");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl liste1.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier entree.txt
Ligne 2 du fichier entree.txt
Ligne 3 du fichier entree.txt
Ligne 4 du fichier entree.txt
Ligne 5 du fichier entree.txt
Ligne 6 du fichier entree.txt
Ligne 7 du fichier entree.txt
Ligne 8 du fichier entree.txt
Ligne 9 du fichier entree.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme liste2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>@ARGV = ("e1.txt","e2.txt");
while ($ligne = &lt;&gt;){
  print("$ligne");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl liste2.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier e1.txt
Ligne 2 du fichier e1.txt
Ligne 3 du fichier e1.txt
Ligne 4 du fichier e1.txt
Ligne 5 du fichier e1.txt
Ligne 1 du fichier e2.txt
Ligne 2 du fichier e2.txt
Ligne 3 du fichier e2.txt
Ligne 4 du fichier e2.txt
Ligne 5 du fichier e2.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme liste3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>while ($ligne = &lt;&gt;){
  print("$ligne");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl liste3.pl entree.txt<SPAN class=rouge>ent</SPAN> 
Ligne 1 du fichier entree.txt
Ligne 2 du fichier entree.txt
Ligne 3 du fichier entree.txt
Ligne 4 du fichier entree.txt
Ligne 5 du fichier entree.txt
Ligne 6 du fichier entree.txt
Ligne 7 du fichier entree.txt
Ligne 8 du fichier entree.txt
Ligne 9 du fichier entree.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme liste4.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>while ($ligne = &lt;&gt;){
  print("$ligne");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl liste4.pl e1.txt,e2.txt<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier e1.txt
Ligne 2 du fichier e1.txt
Ligne 3 du fichier e1.txt
Ligne 4 du fichier e1.txt
Ligne 5 du fichier e1.txt
Ligne 1 du fichier e2.txt
Ligne 2 du fichier e2.txt
Ligne 3 du fichier e2.txt
Ligne 4 du fichier e2.txt
Ligne 5 du fichier e2.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Et, en utilisant la variable standard d'entrée ($_) dont nous avons déjà 
parlé. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme liste5.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>while (&lt;&gt;){
  print;
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl liste5.pl entree.txt<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier entree.txt
Ligne 2 du fichier entree.txt
Ligne 3 du fichier entree.txt
Ligne 4 du fichier entree.txt
Ligne 5 du fichier entree.txt
Ligne 6 du fichier entree.txt
Ligne 7 du fichier entree.txt
Ligne 8 du fichier entree.txt
Ligne 9 du fichier entree.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Surprenant, non ! </H3>
<H2>Accés aux fichiers.</H2>
<H3>L'opérateur diamand est extrèmement utile lorsque les données sont à lire 
sur un seul fichier et sont exclusivement accessibles en lecture.<BR>Pour 
pouvoir accéder simultanément à plusieurs fichiers en lecture ou/et en écriture, 
il est nécessaire se passer par des descripteurs explicites. 
<H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Opération.</TH>
    <TH>Instruction.</TH></TR>
  <TR>
    <TD>Ouverture d'un fichier en lecture.</TD>
    <TD>open (DESC, "nom");</TD></TR>
  <TR>
    <TD>Ouverture d'un fichier en écriture.</TD>
    <TD>open (DESC, "nom");</TD></TR>
  <TR>
    <TD>Ouverture d'un fichier en écriture incrémentale </TD>
    <TD>open (DESC, "&gt;&gt;nom");</TD></TR>
  <TR>
    <TD>Ouverture d'un fichier en lecture / écriture.</TD>
    <TD>open (DESC, "+&gt;nom");</TD></TR>
  <TR>
    <TD>Fermeture d'un fichier.</TD>
    <TD>close (DESC);</TD></TR></TBODY></TABLE>
<H3>DESC est le nom du descripteur qui va désormais permettre d'accéder au 
fichier en question.<BR>"nom" est la chaîne de caractères indiquant le nom du 
fichier.<BR>Lorsqu'on ouvre un fichier en écriture, le fichier, qu'il existe ou 
nom, est détruit et l'écriture commence au début.<BR>Lorsqu'on ouvre un fichier 
en lecture incrémentale, les écritures commencent à la fin du fichier existant. 
toutes les informations qu'il contient sont ainsi conservées.<BR>Exemples : 
</H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme</TH>
    <TH>Commentaire</TH></TR>
  <TR>
    <TD><PRE>open (ENTREE, "donnees.txt");
while(&lt;ENTREE&gt;){
  print;
}
close(ENTREE);
    </PRE></TD>
    <TD>Ouverture du fichier "donnees.txt" en lecture et accés séquentiel à 
      ses informations. </TD></TR>
  <TR>
    <TD><PRE>open (SORTIE, "resultats.txt");
for ($i=1;$i&lt;=100;$i++) {
  print SORTIE ("$i/n");
}
close(SORTIE);
    </PRE></TD>
    <TD>Ouverture du fichier "résultat.txt" en écriture et écriture 
      séquentielle. A la fin, le fichier contiendra les 100 premiers entiers à 
      raison de 1 par ligne. </TD></TR></TBODY></TABLE>
<H2>La boucle foreach.</H2>
<H3>Cette instruction va permettre l'exploration séquentielle de l'ensemble des 
éléments d'une liste. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>foreach $i(@liste) {
  instruction_1;
  instruction_2;
  instruction_3;
}
  </PRE></DIV></DIV>
<H3>La variable $i prend successivement toutes les valeurs de la liste de valeur 
et exécute une fois le corps de programme.<BR>Lorsque le liste de valeurs est 
épuisée, on passe à l'instruction qui suit le corps de programme. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme foreach1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>@a = (1,2,3,4,5);
foreach $i (@a) {
  print "$i ";
}
print ("\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl foreach1.pl<SPAN class=rouge>ent</SPAN>
1 2 3 4 5
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme foreach2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>@a = (1,2,3,4,5);
foreach $i (reverse@a) {
  print "$i ";
}
print ("\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl foreach2.pl<SPAN class=rouge>ent</SPAN>
5 4 3 2 1
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>La variable d'itération est locale au corps de la boucle.<BR>Si une autre 
variable de même nom existe déjà, sa valeur n'en sera pas affectée. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme iter.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>$i = 100;
print "Avant la boucle, i = $i\n";
@a = (1,2,3,4,5);
foreach $i (@a) {
  print "Pendant la boucle, i = $i\n";
}
print "Apres la boucle, i = $i\n";
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl iter.pl<SPAN class=rouge>ent</SPAN>
Avant la boucle, i = 100
Pendant la boucle, i = 1
Pendant la boucle, i = 2
Pendant la boucle, i = 3
Pendant la boucle, i = 4
Pendant la boucle, i = 5
Apres la boucle, i = 100
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme carre.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE># Elever au carre chacun
# des elements d'une liste.
@a = (1,2,3,4,5);
foreach (@a) {
  $_ **= 3;
}
print "@a \n";
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl carre.pl<SPAN class=rouge>ent</SPAN>
1 8 27 64 125
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Listes.htm"><IMG 
style="VERTICAL-ALIGN: middle" 
src="Cours Perl, Les instructions de contrôle_fichiers/prec.gif"> </A>Précédent 
</DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Structctrl.htm"><IMG 
style="VERTICAL-ALIGN: middle" 
src="Cours Perl, Les instructions de contrôle_fichiers/suiv.gif"> 
</A></DIV></H2></H3></H3></BODY></HTML>
