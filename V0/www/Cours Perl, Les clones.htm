<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0049)http://www.dil.univ-mrs.fr/~chris/Perl/Clones.htm -->
<HTML><HEAD><TITLE>Cours Perl, Les clones.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, Les clones_fichiers/Messtyles.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Les clones.</H1>
<H2>Le clonage.</H2>
<H3>Cette particularité n'est utilisable dans toute sa plénitude que sous les 
systèmes Unix. Elle va permettre de dupliquer un processus, c'est à dire créer 
une copie conforme de lui même.<BR>C'est la primitive fork qui permet de 
procéder à cette opération.<BR>Le clone ainsi créé est appelé le fils alors que 
le processus qui lui a donné naissance est appelé le père.<BR>La fonction fork 
retourne :<BR>La valeur numérique zéro (faux) si le processus est le fils.<BR>Le 
numéro (pid) du process si le processus est le père.<BR>Nous allons nous appuyer 
sur des exemples précis afin de montrer toutes les particularités de ce mode de 
programmation et des possibilités de dialogue qu les processus ainsi créés 
peuvent établir. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>if (fork) {
  print "Je suis le pere.\n";
} else {
  print "Je suis le fils.\n";
}
    </PRE></DIV></DIV>
<H3>Trois fonctions permettent une utilisation optimale de la primitive fork. 
</H3>
<DIV class=centre>
<DIV class=prog>exec();<BR>exit();<BR>wait(); </DIV></DIV>
<H3>La primitive pipe (tube) permet, en conjonction avec un fork, d'etablir un 
moyen de communication entre le père et le fils.<BR>Elle s'écrit : </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog>pipe (descripteur_entree, descripteur_sortie); </DIV></DIV>
<H2>Exec.</H2>
<H3>La fonction "exec" est equivalente à la fonction "system".<BR>Toutefois, au 
lieu de créer un nouveau processus pour mettre en oeuvre lacommande shell, elle 
remplace le processus courant par le shell (c'est à direqu'un nouveau shell se 
lance (au sens Unix du terme).<BR>Il faut noter dans ces conditions que 
l'interpréteur ayant étéremplacé par le shell en question, il n'existe 
plus.<BR>Ainsi par exemple, la commande : </H3>
<DIV class=centre>
<DIV class=prog>exec("pwd"); </DIV></DIV>
<H3>Remplacera le processus Perl courant par la commande pwd, le résultat de 
cette commande, l'impression du répertoire courant, apparaitra sur la sortie 
standard du programme Perl, et à la fin de l'exécution de cette commande, rien 
de plus n'arrivera car l'interpréteur aura disparu.<BR>Pour éviter cette fin 
brutale, on utilise de préférence la fonction : </H3>
<DIV class=centre>
<DIV class=prog>system ("pwd"); </DIV></DIV>
<H2>La primitive fork().</H2>
<H3>Ainsi que nous l'avons dit, cette primitive permet de cloner un 
processus.<BR>Nous allons nous en servir pour écrire au moyen de la fonction : 
</H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog>exec("pwd"); </DIV></DIV>
<H3>l'équivalent de la fonction </H3>
<DIV class=centre>
<DIV class=prog>system ("pwd"); </DIV></DIV>
<H3>Il suffit pour celà de cloner le processus et de substituer au fils ainsi 
créé le processus que l'on souhaite voir s'exécuter. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>Equivalent de la fonction system ("pwd")
# En utilisant exec et fork.
# Si le processus est le pere, alors on ne fait rien.
unless (fork) {
  # Si le processus est le fils,
  # on le remplace par la commande pwd.
  exec ("pwd");
}
    </PRE></DIV></DIV>
<H3>L'inconvénient(ou l'avantage) de cette méthode est que les deux processus 
père et fils s'exécutent en parallèle, les entrées sorties éventuelles peuvent 
de ce fait être enchevétrées </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>pipe (ENTREE, SORTIE);
$pid = fork();
if ($pid != 0) {
  #Ici c'est le pere...
  waitpid ($pid,0);
  print ("Cette ligne est imprimée par le pere.\n");
} else {
  #Ici c'est le fils...
  print ("Cette ligne est imprimée par le fils.\n");
  print ("$ligne");
  exit (0);
}
    </PRE></DIV></DIV>
<H2>Utilisation du 'waitpid' et du 'fork'.</H2>
<H3>Wait().</H3>
<H3>La fonction wait permet à un processus père d'attendre jusqu'à ce que le 
fils qu'il aura créé se soit terminé.<BR>Il est ainsi possible d'éviter 
l'enchevètrement des entrée sorties du processus père et du processus fils. 
</H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>#Equivalent de la fonction system ("pwd")
# En utilisant exec et fork.
# Si le processus est le pere, 
# On ne fait rien.
unless (fork) {
  #Si le processus est le fils
  # On le remplace par la commande pwd.
  exec ("pwd");
}
#Le processus pere attend alors que l'exécution
# du processus qu'il vient de creer se termine
# avant de continuer de s'executer.
wait;
    </PRE></DIV></DIV>
<H3>Waitpid</H3>
<H3>Cette fonction attend un évènement donné venant d'un fils 
particulier.<BR></H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog>waitpid ($identification_du_process, $evenement) </DIV></DIV>
<H3>Nous allons voir maintenant comment établir une communication entre le père 
et le fils au moyen du 'pipe' et du 'fork'.<BR>La fonction exit permet de 
terminer immédiatement le processus courant. On utilisera cette commande pour 
tuer Perl de n'importe quelle partie du programme. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>pipe (ENTREE, SORTIE);
$pid = fork();
if ($pid != 0) {
  #Ici c'est le pere...
  close (ENTREE);
  print ("Donnez de l'information a transmettre a mon fils : \n");
  $ligne = &lt;stdin&gt;;
  print SORTIE ($ligne);
} else {
  #Ici c'est le fils...
  close (SORTIE);
  $ligne = &lt;ENTREE&gt;;
  print ("Voici l'information que m'a transmise mon pere :\n");
  print ("$ligne");
  exit (0);
}
    </PRE></DIV></DIV>
<H3>Et pour terminer, un dialogue à double sens entre le père et le 
fils.<BR>Dans l'exemple suivant, le père demande à lire une valeur numérique. Il 
la transmet alors à son fils, ce dernier l'élève au carré et la renvoie à son 
père qui peut alors l'imprimer. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE># Déclaration de deux tubes de communication.
# Le premier permet au pere d'ecrire et au fils de lire.
# Le second permet au fils d'ecrire et au pere de lire.
pipe(LIT_P,ECRIT_F);
pipe(LIT_F,ECRIT_P);
# Purge des deux tubes afin de valider les échanges.
local($fh)=select ECRIT_F; $|=1;select $fh;
local($fh)=select ECRIT_P; $|=1;select $fh;
if ($pid = fork) {
  # Ici on est dans le pere.
  # Le pere ferme les tubes d'acces dont il n'a pas besoin
  # afin que son fils puisse les utiliser.
  close LIT_P;close ECRIT_P;
  # Le pere transmet une valeur à son fils.
  print ECRIT_F "$A\n";
  # Puis il recupere ce que lui retourne son fils.
  chomp($A=&lt;LIT_F&gt;);
  # Il ferme tous les tubes.
  close LIT_F;close ECRIT_F;
  # Et attend la fin.
  waitpid($pid,0);
}else {
  # La on est dans le fils.
  die "Pas moyen : $!" unless defined $pid;
  # Le fils ferme les tubes d'acces dont il n'a pas besoin
  # afin que son pere puisse les utiliser.
  close LIT_F;close ECRIT_F;
  # Le fils lit la valeur transmise par son pere.
  chomp($B=&lt;LIT_P&gt;);
  # Il l'eleve au carre.
  $B**=2;
  # Et la retransmet à son pere.
  print ECRIT_P "$B\n";
  # Il ferme tous les tubes.
  close LIT_P;close ECRIT_P;
  # Et se termine.
  exit;
}
    </PRE></DIV></DIV>
<H3>Autre exemple, un père créée un clone qui va procéder à l'effacement de 
fichiers dont il n'a plus besoin. Pendant le processus d'effacement, le père 
peut continuer son travail.<BR>Le processus fils se détruit lorsqu'il a terminé 
sa tache. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE># Effacement de fichiers inutiles
# en parallèle à l'exécution du programme.
unless (fork) {
  #Si le processus est le fils, alors 
  # On efface tous les fichiers du répertoire /chris/Perl/tmp
  unlink &lt;/chris/Perl/tmp/*&gt;;
  #Le processus fils etant un clone de son pere
  # Il est important de le stoper ici.
  # Sinon il continuerait sur la suite du programme.
  exit;
}
# Si le processus est le pere l'execution se poursuit ici.
# Suite du programme.
    </PRE></DIV></DIV>
<H2>Comment terminer un programme.</H2>
<H3>Les fonctions die et warn ont déjà été évoquées. Elles permettent de 
transmettre des messages urgents à l'utilisateur sur &lt;STDERR&gt;<BR>Nous 
avons utilisé la fonction die lors de la gestion des fichiers: </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog>open (FICHIER, "/tmp/fichier") or<BR>die("Desole, impossible 
d'acceder a /tmp/fichier.\n"); </DIV></DIV>
<H3>Elle permet de terminer un programme .<BR>Nous avons aussi montré comment la 
présence ou l'absence du caractère \n influençait le message qui était imprimé 
sur la sortie erreur. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme die1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source>@mess = ("Je"," suis"," en"," train"," de"," 
      mourir.");<BR>die(@mess); </TD>
    <TD class=prog>c:\progs&gt; perl die1.pl<SPAN class=rouge>ent</SPAN><BR># 
      Je suis en train de mourir.<BR>File 'die1.pl'; Line 2<BR>c:\progs&gt; 
  </TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme die2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source>@mess = ("Je"," suis"," en"," train"," de"," 
      mourir.");<BR>die(@mess\n); </TD>
    <TD class=prog>c:\progs&gt; perl die2.pl<SPAN class=rouge>ent</SPAN><BR># 
      Je suis en train de mourir.<BR>c:\progs&gt; </TD></TR></TBODY></TABLE>
<H3>Autre fonction, "warn()", qui a exactement les mêmes propriétés que la 
fonction die, à la différence prés qu'elle ne termine pas le programme. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme warn1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source>@mess = ("Je"," suis"," en"," train"," de"," 
      mourir.");<BR>warn(@mess);<BR>print ("Suite du programme...\n"); </TD>
    <TD class=prog>c:\progs&gt; perl warn1.pl<SPAN class=rouge>ent</SPAN><BR># 
      Je suis en train de mourir.<BR>File 'warn1.pl'; Line 2<BR>Suite du 
      programme...<BR>c:\progs&gt; </TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme warn2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source>@mess = ("Je"," suis"," en"," train"," de"," 
      mourir.");<BR>warn(@mess\n);<BR>print ("Suite du programme...\n"); </TD>
    <TD class=prog>c:\progs&gt; perl warn2.pl<SPAN class=rouge>ent</SPAN><BR># 
      Je suis en train de mourir.<BR>Suite du programme...<BR>c:\progs&gt; 
  </TD></TR></TBODY></TABLE>
<H3>Et si on s'amusait un peu ? </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme xwarn3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source>@warn = ("Je"," crois"," que"," je"," vais"," 
      mourir.");<BR>warn ("@warn\n");<BR>print ("En fait, pas tout a fait 
      !!!");<BR>@die = ("La"," je"," suis"," vraiment"," mort.");<BR>die 
      ("@die\n"); </TD>
    <TD class=prog>c:\progs&gt; perl warn3.pl<SPAN class=rouge>ent</SPAN> 
      <BR># Je crois que je vais mourir.<BR># La je suis vraiment mort.<BR>En 
      fait, pas tout a fait !!!<BR>c:\progs&gt; </TD></TR></TBODY></TABLE>
<H3>Si vous avez toujours en mémoire ce qui a été dit sur la gestion des sorties 
&lt;STDERR&gt; et &lt;STDIN&gt;, cette étrangeté ne doit poser aucun problème. 
</H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme xxx.xx</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source>$| = 1;<BR>@warn = ("Je"," crois"," que"," je"," vais"," 
      mourir.");<BR>warn ("@warn\n");<BR>print ("En fait, pas tout a fait 
      !!!");<BR>@die = ("La"," je"," suis"," vraiment"," mort.");<BR>die 
      ("@die\n"); </TD>
    <TD class=prog>c:\progs&gt; perl xxx.xx<SPAN class=rouge>ent</SPAN> <BR># 
      Je crois que je vais mourir.<BR>En fait, pas tout a fait !!! <BR># La je 
      suis vraiment mort.<BR>c:\progs&gt; </TD></TR></TBODY></TABLE>
<H2>Autres fonctions.</H2>
<H3>Exit, que nous avons déjà vu à propos des clones. </H3>
<DIV class=centre>
<DIV class=prog>exit ($valeur_de_retour); </DIV></DIV>
<H3>Kill, qui permet, comme son nom l'indique, de tuer un process.<BR>Voir la 
commande Unix correspondante pour plus de détails. </H3>
<DIV class=centre>
<DIV class=prog>kill ($signal, @liste_de_processus); </DIV></DIV>
<H3>sleep permet d'interrompre le déroulement du programme pendant un nombre de 
secondes donné. </H3>
<DIV class=centre>
<DIV class=prog>sleep ($nombre_de_secondes); </DIV></DIV>
<H3>Time que nous avons déjà vue et qui permet aussi de calculer le temps 
utilisé par des processus.<BR>Cette fonction, lorsqu'elle est appellée sans 
arguments, renvoie une liste qui contient :<BR>Le temps utilisé par le 
programme.<BR>Le temps système utilisé par le programme.<BR>Le temps utilisé par 
le fils (si il existe).<BR>Le temps système utilisé par le fils (si il existe). 
</H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme xtime.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source>@list = times;<BR>print ("Debut du 
      programme.\n");<BR>sleep (10);<BR>print ("Fin du programme, decompte du 
      temps :\n");<BR>$~="TEMPS";<BR>write;<BR>format TEMPS =<BR>Temps utilise 
      par le programme : @###.##<BR>$list[0];<BR>Temps systeme utilise par le 
      programme : @###.##<BR>$list[1];<BR>Temps utilise par le fils : 
      @###.##<BR>$list[2];<BR>Temps systeme utilise par le fils : 
      @###.##<BR>$list[3]; </TD>
    <TD class=prog>c:\progs&gt; perl time.pl<SPAN class=rouge>ent</SPAN> 
      <BR>Début du programme.<BR>Fin du programme, décompte du temps :<BR>Temps 
      utilisé par le programme : 0.05<BR>Temps système utilisé par le programme 
      : 0.00<BR>Temps utilisé par le fils : 0.00<BR>Temps système utilisé par le 
      fils : 0.00<BR>c:\progs&gt; </TD></TR></TBODY></TABLE>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A href="http://www.dil.univ-mrs.fr/~chris/Perl/Unix.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Les clones_fichiers/prec.gif"> 
</A>Précédent </DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Sockets.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Les clones_fichiers/suiv.gif"> 
</A></DIV></H2></BODY></HTML>
