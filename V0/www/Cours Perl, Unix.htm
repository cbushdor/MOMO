<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0047)http://www.dil.univ-mrs.fr/~chris/Perl/Unix.htm -->
<HTML><HEAD><TITLE>Cours Perl, Unix.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, Unix_fichiers/Messtyles.css" type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Interface avec Unix.</H1>
<H2>Les fonctions Read et Write.</H2>
<H3>Pour effectuer des entrées/sorties, Perl propose, outre les diverses 
fonctions que nous<BR>venons de voir, des fonctions équivalentes à celles 
proposées par le système Unix. </H3>
<H3>Les deux fonctions read() et sysread() sont quasiment 
équivalentes.<BR>read() est identique à la fonction fread() de 
Unix.<BR>sysread() est identique à la fonction read() de Unix.<BR>Pour de plus 
amples informations, il est recommandé de se reporter au manuel Unix. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>read (identificateur, résultat, longueur, saute);
sysread (identificateur, résultat, longueur, saute);
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>identificateur</TH>
    <TH>Identification du fichier.</TH></TR>
  <TR>
    <TD>&gt;résultat</TD>
    <TD>Scalaire ou table ou seront rangées les données.</TD></TR>
  <TR>
    <TD>longueur</TD>
    <TD>Nombre de caractères à lire.</TD></TR>
  <TR>
    <TD>saute</TD>
    <TD>Variable optionnelle permettant d'indiquer unnombre de caractères a 
      sauter au début du fichier.</TD></TR></TBODY></TABLE>
<H3>La fonction syswrite est identique à la fonction writede Unix.<BR>Voir le 
manuel Unix pour plus de détail. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>syswrite (identificateur, résultat, longueur, saute
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>identificateur</TH>
    <TH>Identification du fichier.</TH></TR>
  <TR>
    <TD>résultat</TD>
    <TD>Scalaire ou table ou seront rangées les données.</TD></TR>
  <TR>
    <TD>longueur&gt;</TD>
    <TD>Nombre de caractères à écrire.</TD></TR>
  <TR>
    <TD>saute</TD>
    <TD>Variable optionnelle permettant d'indiquer unnombre de caractères a 
      sauter avant de commencer l'écriture.</TD></TR></TBODY></TABLE>
<H3>Les tests de fichier vont permettre, comme dans le système unix, de 
caractériser un fichier. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Extension.</TH>
    <TH>Test effectué</TH></TR>
  <TR>
    <TD>-r
      <DIV></DIV></TD>
    <TD>Le répertoire ou le fichier est accessible en lecture.</TD></TR>
  <TR>
    <TD>-w</TD>
    <TD>Le répertoire ou le fichier est accessible en écriture./td&gt; </TD>
  <TR>
    <TD>-x</TD>
    <TD>Le répertoire ou le fichier est accessible en exécution.</TD></TR>
  <TR>
    <TD>-o</TD>
    <TD>Le répertoire ou le fichier appartient à l'usager.</TD></TR>
  <TR>
    <TD>-R</TD>
    <TD>Le répertoire ou le fichier est accessible en lecture parl'usager 
      réel, mais pas par l'usager effectif.</TD></TR>
  <TR>
    <TD>-W</TD>
    <TD>Le répertoire ou le fichier est accessible en écriture par l'usager 
      réel, mais pas par l'usager effectif.</TD></TR>
  <TR>
    <TD>-X</TD>
    <TD>Le répertoire ou le fichier est accessible en exécution par l'usager 
      réel, mais pas par l'usager effectif.</TD></TR>
  <TR>
    <TD>-O</TD>
    <TD>Le répertoire ou le fichier appartient à l'usager réel, mais pas par 
      l'usager effectif.</TD></TR>
  <TR>
    <TD>-e</TD>
    <TD>Le répertoire ou le fichier existe.</TD></TR>
  <TR>
    <TD>-z</TD>
    <TD>Le répertoire ou le fichier est de taille nulle.</TD></TR>
  <TR>
    <TD>-s</TD>
    <TD>Le répertoire ou le fichier existe, sa taille n'est pas nulle, la 
      valeur est la taille du fichier en bytes.</TD></TR>
  <TR>
    <TD>-f</TD>
    <TD>L'entrée représente un fichier vrai.</TD></TR>
  <TR>
    <TD>-d</TD>
    <TD>L'entrée représente un répertoire.</TD></TR>
  <TR>
    <TD>-l</TD>
    <TD>L'entrée représente un lien symbolique.</TD></TR>
  <TR>
    <TD>-S</TD>
    <TD>L'entrée représente un socket.</TD></TR>
  <TR>
    <TD>-p&lt;</TD>
    <TD>&gt;L'entrée représente un tube (par exemple une file "fifo".</TD></TR>
  <TR>
    <TD>-b</TD>
    <TD>L'entrée représente un fichier spécial (une partition montée).</TD></TR>
  <TR>
    <TD>-c</TD>
    <TD>L'entrée représente un fichier spécial caractère (périph I/O).</TD></TR>
  <TR>
    <TD>-u</TD>
    <TD>Le répertoire ou le fichier a le setuid positionné.</TD></TR>
  <TR>
    <TD>-g</TD>
    <TD>Le répertoire ou le fichier a le setgid positionné.</TD></TR>
  <TR>
    <TD>-k</TD>
    <TD>Le répertoire ou le fichier a le sticky bit positionné.</TD></TR>
  <TR>
    <TD>-t</TD>
    <TD>isatty () sur le gestionnaire du fichier est vrai.</TD></TR>
  <TR>
    <TD>-T</TD>
    <TD>Le fichier est de type "texte".</TD></TR>
  <TR>
    <TD>-B</TD>
    <TD>Le fichier est de type "binaire".</TD></TR>
  <TR>
    <TD>-M</TD>
    <TD>Date de dernière modification en jours.</TD></TR>
  <TR>
    <TD>-A</TD>
    <TD>Date de dernier accés en jours</TD></TR>
  <TR>
    <TD>-C</TD>
    <TD>Date de la dernière modification du Inode en 
jours.</TD></TR></TBODY></TABLE>
<H3>Si la plupart de ces tests donnent un résultat de type vrai/faux, certains 
permettent d'obtenir des réponses plus élaborées. Ainsi par exemple, l'opérateur 
-s qui retourne la taille en byte du fichier concerné.<BR>Cette valeur peut donc 
être interprétée comme un résultat vrai' si elle est non nulle et 'faux' si elle 
est nulle. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>.......
open (MOTSDEPASSE, "MotsDePasse");
.......
if (-o MOTSDEPASSE) {.....}
.......
if (-w MotsDePasse) {.....}
  </PRE></DIV></DIV>
<H3>Les opérateurs -M, -A, -C retournent un nombre de jours, permettant ainsi de 
caractériser les dates d'accés au fichier. La valeur retournée est fractionnaire 
avec une résolution d'une seconde, 36 heures représentent donc 1,5 jours.<BR>Il 
faut être attentif car la comparaison se fait à la seconde prés 3 jours 
équivalent à 21600 secondes et pas à 21601 ni à 21599.<BR>Vu la précision, il 
est recommandé de tester par rapport à une fourchette plutot que sur une valeur 
exacte (entre 2,5 et 3,5 jours). Ces opérateurs agissent aussi bien sur le 
fichier lui même que sur son gestionnaire. </H3>
<H3>Si aucun fichier n'est explicitement spécifié, ('if -f)', alors le test se 
fera sur l'entrée standard ($_) </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>if -f {
  .....
}
  </PRE></DIV></DIV>
<H3>Est parfaitement équivalent a. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>if -f $_ {
  .....
}
  </PRE></DIV></DIV>
<H3>On peut facilement tester une liste de noms de fichiers. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>foreach (@Liste_de_noms_de_fichiers) {
  print "$_ existe.\n" if -e;
}
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme unix1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@l = (A1,A2,A3,A4,A5,A6,A7,A8,A9,A10);
foreach (@liste) {
  print "le fichier $_ existe.\n" if -e;
  print "le fichier $_ n'existe pas.\n" if !-e;
}
    </PRE></TD>
    <TD class=prog><PRE>coruscant:~ chris$ unix1.pl<SPAN class=rouge>ent</SPAN>
le fichier A1 existe.
le fichier A2 existe.
le fichier A3 existe.
le fichier A4 n'existe pas.
le fichier A5 existe.
le fichier A6 n'existe pas.
le fichier A7 existe.
le fichier A8 n'existe pas.
le fichier A9 n'existe pas.
le fichier A10 n'existe pas.
coruscant:~ chris$
    </PRE></TD></TR></TBODY></TABLE>
<H3>Dans le même ordre d'idée, il est possible de procéder au test de 
l'existence d'une famille de fichiers. Si dans notre système nous avons une 
famille de fichiers destinée à mémoriser des mots de passe. En affectant à ce 
groupe de fichiers l'extension .mdp nous nous donons la possibilité de les 
explorer. Ainsi le sous programme suivant explore les fichiers qui portent cette 
extension et ne retient comme valides que ceux qui ont été modifiés depuis moins 
de 7 jours. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>sub lect_mots {
  while ($fichier = *.mdp) {
    open (MOTSDEPASSE, "$fichier");
    if (-M MOTSDEPASSE &gt; 7) {
      while ($nom = <MOTSDEPASSE>) {
        chop ($nom);
        $mot = <MOTSDEPASSE>;
        chop ($mot);
        $mots{$nom} = $mot;
      }
    }
    close (MOTSDEPASSE);
  }
}
  </PRE></DIV></DIV>
<H2>Les opérateurs stat( ) et lstat ( ).</H2>
<H3>Ces opérateurs vont permettre de tester les attributs des 
fichiers.<BR>L'opérateur stat() appliqué à un gestionnaire de fichiers va 
permettre de récupérer les 13 informations relatives à ce fichier. Ce son. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>$dev</TD>
    <TD>Numéro de périphérique du système de fichier (device)</TD></TR>
  <TR>
    <TD>$ino</TD>
    <TD>Numéro d'Inode.</TD></TR>
  <TR>
    <TD>$mode</TD>
    <TD>Mode du fichier, type et autorisations.</TD></TR>
  <TR>
    <TD>$nlink</TD>
    <TD>Nombre de liens en dur sur le fichier.</TD></TR>
  <TR>
    <TD>$uid</TD>
    <TD>Numéro d'identification du propriétaire du fichier.</TD></TR>
  <TR>
    <TD>$gid</TD>
    <TD>Numéro d'identification du groupa auquel appartient le propriétaire du 
      fichier.</TD></TR>
  <TR>
    <TD>$rdev</TD>
    <TD>Identification du périphérique. Ne concerne que les fichiers 
    spéciaux.</TD></TR>
  <TR>
    <TD>$size</TD>
    <TD>Taille totale du fichier en octets.</TD></TR>
  <TR>
    <TD>$atime</TD>
    <TD>Date du dernier accés au fichier</TD></TR>
  <TR>
    <TD>$mtime&gt;</TD>
    <TD>Date de la dernière modification du fichier.</TD></TR>
  <TR>
    <TD>$ctime</TD>
    <TD>Date de changement de l'Inode du fichier.</TD></TR>
  <TR>
    <TD>$blksize</TD>
    <TD>Taille de bloquage pour les entrées/sorties sur le système de 
    fichier.</TD></TR>
  <TR>
    <TD>$blocks</TD>
    <TD>Nombre de blocs réellement alloués.</TD></TR></TBODY></TABLE>
<DIV class=centre style="WIDTH: 50em">
<DIV class=prog><PRE>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks)= stat(...);
  </PRE></DIV></DIV>
<H3>$dev et $ino permettent l'identification unique d'un fichier.<BR>Les valeurs 
$blksize et $blocks ne sont accessibles que sur les systèmes BSD et dérivés. 
Dans ces conditions, le champ $blocks est donné en multiples de 512 
octets.<BR>Il faut aussi noter que $size peut être fortement différent de 
$blocks*512, ceci est du au fait que le fichier peut contenir des blocs non 
aloués, c'est à dire des trous qui ne sont pas comptabilisés.<BR>Appliqué à un 
lien symbolique, l'opérateur stat () retourne l'information<BR>indiquant qu'il 
s'agit bien d'un lien symbolique, mais ne donne aucune information sur le 
fichier cible de ce lien.<BR>Cette information ne peut être obtenue que par 
l'opérateur lstat ().<BR>Il existe un descripteur de fichier que l'on représente 
par le caractère "_" (blanc souligné), mais son utilisation est dangereuse et 
nécessite une grande attention.<BR></H3>
<H2>Test de l'age d'un fichier.</H2>
<H3>Réécrivons la procédure lect_mots en testant l'âge du fichier de mots de 
passe. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>sub lect_mots {
  open (MOTSDEPASSE, "MotsDePasse");
  if (-M MOTSDEPASSE &gt; 7) {
    die "Désole, Fichier trop vieux..."
  }
  while ($nom = <MOTSDEPASSE>) {
    chop ($nom);
    $mot = <MOTSDEPASSE>;
    chop ($mot);
    $mots{$nom} = $mot;
  }
  close (MOTSDEPASSE);
}
  </PRE></DIV></DIV>
<H3>L'opérateur -M permet de récupérer le temps écoulé depuis la dernière 
modification du fichier.<BR>L'opérateur die, comme nous l'avons déjà vu, permet 
de suspendre le déroulement du programe, le message est envoyé à l'usager et le 
programme se termine. </H3>
<H3>Appelé par l'instruction &amp;lec_mots, sur un fichier trop ancien, cette 
procédure donne le résultat : </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme unix2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
sub lect_mots {
  open (MOTSDEPASSE, $_[0]);
  if (-M MOTSDEPASSE &gt; 7) {
    die "Désole, Fichier trop vieux..."
  }
  while ($nom = <MOTSDEPASSE>) {
    chop ($nom);
    $mot = <MOTSDEPASSE>;
    chop ($mot);
    $mots{$nom} = $mot;
  }
  close (MOTSDEPASSE);
}
&amp;lec_mot(perrime);
    </PRE></TD>
    <TD class=prog><PRE>coruscant:~ chris$ perl unix2.pl<SPAN class=rouge>ent</SPAN>
# Désole, Fichier trop vieux...
File 'chris/unix2'; Line 5
coruscant:~ chris$
    </PRE></TD></TR></TBODY></TABLE>
<H2>La gestion de l'heure.</H2>
<H3>Il existe, en Perl, plusieurs fonctions qui permettent d'obtenir la date et 
l'heure. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>time;
localtime;
gmtime;
  </PRE></DIV></DIV>
<H3>La fonction time, à l'instar de la fonction de même nom de Unix, renvoie un 
scalaire qui indique le nombres de secondes qui se sont écoulées depuis le 1er 
Janvier 1970 à 0 heures.<BR>localtime; permet de récupérer les données relatives 
au temps local.<BR>gmtime; permet de récupérer les données relatives au temps 
universel. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme unix3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$t = time;
print ("Depuis le 1/1/1970\n");
print ("$t secondes se sont écoulées.\n");
$t = localtime;
print ("Date locale : $t\n");
$t = gmtime;
print ("Date universelle : $t\n");
    </PRE></TD>
    <TD class=prog><PRE>coruscant:~ chris$ perl unix3.pl<SPAN class=rouge>ent</SPAN>
Depuis le 1/1/1970
1057915709 secondes se sont écoulées.
Date locale : Fri Jul 11 11:28:29 2003
Date universelle : Fri Jul 11 09:28:29 2003
coruscant:~ chris$
    </PRE></TD></TR></TBODY></TABLE>
<H3>Si on désire procéder soi même à la conversion de la valeur renvoyée par la 
fonction time, il suffit de soumettre cette valeur à l'une des fonctions 
localtime ou gmtime. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>localtime(time);
gmtime(time);
  </PRE></DIV></DIV>
<H3>La valeur renvoyée est une liste de valeurs qui sont, dans l'ordre. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD><SPAN class=rouge>57</SPAN> 42 11 11 6 103 5 191 1 </TD>
    <TD>Les secondes (0 .. 59). </TD></TR>
  <TR>
    <TD>57 <SPAN class=rouge>42</SPAN> 11 11 6 103 5 191 1 </TD>
    <TD>Les minutes (0 .. 59). </TD></TR>
  <TR>
    <TD>57 42 <SPAN class=rouge>11</SPAN> 11 6 103 5 191 1 </TD>
    <TD>l'heure (0 .. 23). </TD></TR>
  <TR>
    <TD>57 42 11 <SPAN class=rouge>11</SPAN> 6 103 5 191 1 </TD>
    <TD>Le jour dans le mois (1 .. 31). </TD></TR>
  <TR>
    <TD>57 42 11 11 <SPAN class=rouge>6</SPAN> 103 5 191 1 </TD>
    <TD>Le mois (1 .. 31). </TD></TR>
  <TR>
    <TD>57 42 11 11 6 <SPAN class=rouge>103</SPAN> 5 191 1 </TD>
    <TD>L'année relativement à 1900. </TD></TR>
  <TR>
    <TD>57 42 11 11 6 103 <SPAN class=rouge>5</SPAN> 191 1 </TD>
    <TD>Le jour dans la semaine (0 .. 6). </TD></TR>
  <TR>
    <TD>57 42 11 11 6 103 5 <SPAN class=rouge>191</SPAN> 1 </TD>
    <TD>Le jour dans l'année (0 .. 364). </TD></TR>
  <TR>
    <TD>57 42 11 11 6 103 5 191 <SPAN class=rouge>1</SPAN> </TD>
    <TD>L'indication heure d'hiver (0) heure d'été (1). </TD></TR></TBODY></TABLE>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>coruscant:~ chris$ cat unix4.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
@jours = ("Dimanche","Lundi","Mardi","Mercredi",
          "Jeudi","Vendredi","Samedi"),
@mois = ("Janvier","Février","Mars","Avril","Mai","Juin","Juillet",
         "Aout","Septembre","Octobre","Novembre","Decembre"),
($ss,$mm,$hh,$jj,$mo,$aa,$js,$ja,$st) = localtime(time);
$annee = $aa + 1900;
print ("Nous sommes le $jours[$js] $jj $mois[$mo] $annee\n");
print ("Il est $hh heures, $mm minutes, $ss secondes\n");
print ("Ce jour est le $ja eme de l'annee\n");
print ("Nous sommes en heure d'",("hiver","ete")[$st==1],".\n");
coruscant:~ chris$ perl unix4.pl<SPAN class=rouge>ent</SPAN>
Nous sommes le Vendredi 11 Juillet 2003
Il est 11 heures, 54 minutes, 21 secondes
Ce jour est le 191 eme de l'annee
Nous sommes en heure d'ete.
coruscant:~ chris$
  </PRE></DIV></DIV>
<H2>La navigation dans les répertoires.</H2>
<H3>La fonction chdir() est un appel système qui permet de se déplacer dans les 
arborescences. </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>chdir("/etc") || die "Surprise .. /etc est inaccessible .";
  </PRE></DIV></DIV>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>print "Quel repertoire voulez vous atteindre ? ";
chomp ($rep = <STDIN>);
if (chdir ($rep)) {
  print ("le changement de repertoire a reussi.\n");
} else {
  print ("le changement de repertoire a echoue.\n");
  </PRE></DIV></DIV>
<H3>Chercher dans /usr tous les noms de fichiers qui commencent par cat.<BR>Pour 
cette opération, on déclare une pseudo table @a =&lt;/usr/cat*&gt; que l'on 
explore. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>while ($suivant = </USR cat*> {
# On va supprimer tout ce qui precede le dernier slash
# afin de ne conserver que le nom du fichier.
  $suivant =~ s#.*/##;
  print "Il existe un fichier de nom : $suivant";
}
  </PRE></DIV></DIV>
<H3>Noter au passage le changement de délimiteur de l'expresion régulière. Le 
caractère à tester étant le slash, il est judicieux dans ces conditions de 
déclarer un autre délimiteur, # dans le cas qui nous préoccupe, afin de pouvoir 
faire apparaitre le caractère / dans le corps de l'expression sans le faire 
précéder du \. </H3>
<H3>Il est aussi possible de créer un tableau qui contienne la liste de 
l'ensemble des fichiers d'un répertoire donné. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>#Question : /usr/bin existe-t-il?
if (-d "/usr/bin") {
  # Oui /usr/bin existe.
  $rep = "/usr/bin";
} else {
  # Non/usr/bin n'existe pas.
  $rep = "/bin";
}
#Le tableau @liste contiendra la liste
#des fichiers du répertoire.
@liste = &lt;$rep/*&gt;;
  </PRE></DIV></DIV>
<H2>Les répertoires.</H2>
<H3>Ouverture d'un répertoire </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>opendir (ETC,"/etc") or die "Impossible d'ouvrir /etc";
  </PRE></DIV></DIV>
<H3>Fermeture d'un répertoire </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>closedir (ETC);
  </PRE></DIV></DIV>
<H3>Lecture du contenu d'un répertoire à raison d'un fichier par itération, le 
nom étant stocké dans un scalaire. </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>opendir (ETC,"/etc") or die "Impossible d'ouvrir /etc";
while ($nom = readdir (ETC)) {
  print ("Le fichier $nom est present dans le repertoire /etc.\n");
}
closedir (ETC);
  </PRE></DIV></DIV>
<H3>Lecture du contenu d'un répertoire et tri des fichiers par ordre 
alphabétique. La totalité de la liste sera mémorisée afin de pouvoir procéder au 
tri lexicographique. </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>opendir (ETC,"/etc") or die "Impossible d'ouvrir /etc";
foreach $nom ( sort readdir (ETC))
  print ("Le fichier $nom est present dans le repertoire /etc.\n");
}
closedir (ETC);
  </PRE></DIV></DIV>
<H3>Création d'un répertoire. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>mkdir ("repertoire");
  </PRE></DIV></DIV>
<H3>Création d'un répertoire et mise à jour des droits d'accés. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>mkdir ("repertoire",0755) or
  die "Impossible de créer le repertoire.\n";
  </PRE></DIV></DIV>
<H3>Destruction d'un répertoire. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>rmdir ("repertoire") or
  die "Impossible de détruire le repertoire.\n";
  </PRE></DIV></DIV>
<H3>Modification des droits d'accés pour les fichiers listés. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>chmod (0755,"fich1","fich2",...,"fichn");
  </PRE></DIV></DIV>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>foreach $fichiers ("fich1","fich2",...,"fichn") {
  unless ( chmod (0755,$fichier)) {
   print "Impossible de modifier les droits de $fichier.\n";
  }
}
  </PRE></DIV></DIV>
<H3>Changement de repertoire. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>rename ("nom","repertoire/nom");
  </PRE></DIV></DIV>
<H2>Les fichiers.</H2>
<H3>Destruction d'un fichier. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>unlink ("nom_de_fichier");
  </PRE></DIV></DIV>
<H3>La fonction unlink () retourne la valeur 1 si tout s'est bien passé, 0 dans 
le cas contraire. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>print ("Quel fichier doit-on detruire ?");
chomp ($nom = <STDIN>);
unlink ($nom);
  </PRE></DIV></DIV>
<H3>Destruction de plusieurs fichiers. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>$nom1 = "texte"; $nom2 = "livre"; $nom3 = "essai";
unlink ($nom1,$nom2,$nom3);
  </PRE></DIV></DIV>
<H3>Destruction globale de plusieurs fichiers. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>unlink (&lt;*.o&gt;);
  </PRE></DIV></DIV>
<H3>Dans le cas d'une destruction multiple, la fonction unlink () retourne le 
nombre de fichiers qui ont été détruits.<BR>Si une seule destruction est 
réclamée, alors la valeur de retour sera 1 si la destruction est effective, 0 
dans le cas contraire. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>foreach $fichier (&lt;*.o&gt;) {
  unlink ($fichier) or
    die "probleme pour destruire $fichier.\n";
}
  </PRE></DIV></DIV>
<H3>Même chose, mais en utilisant la variable standard par défaut $_ </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>foreach (&lt;*.o&gt;) {
  unlink or
    die "probleme pour destruire $fichier.\n";
}
  </PRE></DIV></DIV>
<H3>Renommer un fichier. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>rename ("ancien_nom","nouveau_nom");  </PRE></DIV></DIV>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>print ("Fichier a renommer :");
chomp($ancien = <STDIN>);
Print ("Nouveau nom :");
chomp($nouveau = <STDIN>);
rename ($ancien,$nouveau)
  or die "Pas moyen de renommer $ancien en $nouveau.";
  </PRE></DIV></DIV>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>sub lect_mots {
  while ($fichier = &lt;*.mdp&gt;) {
    open (MOTSDEPASSE, "$fichier");
    if (-M MOTSDEPASSE &lt; 7) {
      while ($nom = <MOTSDEPASSE>) {
        chop ($nom);
        $mot = <MOTSDEPASSE>;
        chop ($mot);
        $mots{$nom} = $mot;
      }
    } else {
      # Sile fichier que l'on vient de trouver est trop vieux,
      # on lui rajoute l'extension .old.
      rename ($fichier,"$fichier.old");
    }
  close (MOTSDEPASSE);
  }
}
  </PRE></DIV></DIV>
<H2>Création de liens.</H2>
<H3>Rappels sur les liens. </H3>
<H3>Lien 'hard' : Un tel lien ne peut être différencié d'un nom de 
fichier.<BR>Le noyau unix garde la trace de tous les liens qui sont créés à un 
instant donné.<BR>Lorsqu'un fichier est créé il démare avec un seul lien, chaque 
nouveau lien créé fait croitre ce nombre de 1 et chaque lien détruit fait 
décroitre ce nombre de 1. Il doit toujours référencer un fichier monté sur le 
même volume. </H3>
<H3>Lien 'soft' : C'est en définitive un type spécifique de fichier qui contient 
un chemin complet comme donnée. Il peut éventuellement pointer vers un fichier 
inexistant. </H3>
<H3>Création d'un lien hard. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>link ("nom","lien") or
  die "Pas moyen de lier nom à lien.";
  </PRE></DIV></DIV>
<H3>Il est impératif, pour que l'opération puisse aboutir, que le fichier 
concerné existe. </H3>
<H3>Création d'un lien symbolique. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>symlink ("nom","lien") or
  die "Pas moyen de lier nom à lien.";
  </PRE></DIV></DIV>
<H3>lecture d'un lien symbolique. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>if ($x = readlink ("liaison")) {
  print ("Le lien liaison pointe vers $x\n");
}
  </PRE></DIV></DIV>
<H2>Modification des attributs.</H2>
<H3>Changement de propriétaire. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>chown (uid,gid,"fich1",fich2", ...,"fichn");
  </PRE></DIV></DIV>
<H3>Donne à l'usager (uid,gid) la propriété des fichiers listés. </H3>
<H2>Modification des dates.</H2>
<H3>Rappelons que le temps Unix est compté en secondes à partir du 1 janvier 
1970 à minuit. Ce nombre, représenté sous la forme d'un entier signé sur 32 
bits, est prévu pour exploser aprés 2100 (autour de 2106).<BR>Un fichier est 
caractérisé par trois dates :<BR>Date du dernier accés (quelqu'il soit).<BR>Date 
de la derniere modification (accés en écriture).<BR>Date de la dernière 
modification du inode (tout accés y compris les créations de lien).<BR>Le fait 
de modifier l'une des deux premières valeurs positionne automatiquement la 
troisième à la date courante. </H3>
<DIV class=centre style="WIDTH: 27em">
<DIV class=prog><PRE>$accés = $modif = 808790400;
# (a peu pres le 15 aout 1995)
utime ($acces,$modif,"fich1",fich2", ...,"fichn");
$heure = time + 3600;
# Dans 1 heure
utime ($heure,$heure,"projet");
  </PRE></DIV></DIV>
<H2>Mémorisation du dernier accés d'un usager.</H2>
<H3>On va créer un hash permettant pour chaque usager de savoir combien de temps 
s'est écoulé depuis son dernier accés. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>$Dernier_acces{$nom} = temps;
  </PRE></DIV></DIV>
<H3>La fonction dbmopen() permet de stocker un hash sur un fichier. En fait, le 
stockage est réalisé sous la forme de deux fichiers. </H3>
<H3>Catalogage en utilisant les fichiers qui auront pour noms dernacc.dir et 
dernacc.pag.<BR>Les droits associés à ces fichiers seront 0666. </H3>
<DIV class=centre style="WIDTH: 23em">
<DIV class=prog><PRE>dbmopen(%Dernier_acces,"dernacc",0666);
  </PRE></DIV></DIV>
<H3>Accés standard à un hash pour affecter une valeur. Le fichier disque sera 
automatiquement mis à jour. </H3>
<DIV class=centre style="WIDTH: 17em">
<DIV class=prog><PRE>$Dernier_acces{$nom} = temps;
  </PRE></DIV></DIV>
<H3>Dissociation du hash de son image disque. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>dbmclose (%Dernier_acces);
  </PRE></DIV></DIV>
<H2>Affichage des temps d'accés.</H2>
<H3>L'opérateur keys prend comme argument le nom d'un hash et retourne la liste 
de toutes les clés d'association de ce tableau.<BR>L'opérateur sort permet de 
les trier par ordre alphabétique<BR>L'opérateur foreach, prend la liste qui lui 
est passé en argument et affecte tour à tour chacun des éléments à la variable 
scalaire nom. </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>dbmopen(%Dernier_acces,"dernacc",0666);
$~ = "SORTIE";
foreach $nom (sort keys(%Dernier_acces)) {
  $Quand = $Dernier_acces{$nom} ;
  $temps = (time - $Quand)/ 3600;
  write;
}
format SORTIE =
Nom : @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;, le dernier accés date de @&lt;&lt;&lt; heures.
$nom, $temps
.
  </PRE></DIV></DIV>
<H3>La commande "system" permet de lancer un shell (/bin/sh) avec le paramètre 
donné, elle peut bien se terminer, dans ce cas la valeur de retour est 0, dans 
le cas contraire la valeur de retour est différente de 0. Cette valeur 
correspond au code de retour de la commande au sens Unix du terme. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>system ("cal 1996 &gt; calendrier") and
  die "Impossible de créer le fichier calendrier.\n";
  </PRE></DIV></DIV>
<H3>A noter que l'on est contraint d'utiliser l'opération 'and' à cause de 
l'inversion du code de retour dans unix :<BR>0 : Pas de problème.<BR>1 : Erreur. 
</H3>
<H3>Soit à créer un fichier dont le nom devra être modifié à chaque accés. Pour 
réaliser cette opération, on va par exemple utiliser une chaine constante 
"fich." à laquelle on concatènera une valeur numérique qui sera incrémentée, ce 
qui permettra de créer les noms successifs fich.1, fich.2 ... </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>$nom = "fich.".++i;
  </PRE></DIV></DIV>
<H3>Lister, en tache de fond, le contenu d'un répertoire dans le fichier dont on 
vient de générer le nom. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>system ("ls -al &gt; $nom &amp;");
  </PRE></DIV></DIV>
<H2>Les Quotes d'exécution.</H2>
<H3>Comme dans Unix, elles permettent de récupérer le résultat de l'exécution 
d'une commande. Si la réponse tient dans un seul élément il est possible de 
l'imprimer tel quel. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>$ici = `pwd`;
print "Le repertoire actuel est $ici\n";
  </PRE></DIV></DIV>
<H3>Si la réponse tient sur plusieurs lignes on peut récupérer les divers 
éléments dans une liste. </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>foreach $_ (`who`) {
  ($qui,$ou,$quand) = /(\S+)\s+(\S+)\s+(.*)/;
  print "$qui travaille sur le terminal $ou depuis $quand\n";
}
  </PRE></DIV></DIV>
<H2>Les processus gestionnaires de fichier.</H2>
<H3>Il est possible en Perl de créer un processus qui fasse office de 
gestionnaire de fichier. </H3>
<H3>En entrée. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>open (PROCWHO, "who|");
  </PRE></DIV></DIV>
<H3>PROCWHO est une procédure de lecture qui prendra le résultat de la commande 
who comme s'il s'agissait d'un fichier. A noter le pipe (|) à droite du who et 
qui indique au langage que PROCWHO n'est pas un nom de fichier mais une commande 
à exécuter.<BR>Cette procédure sera utilisée sous la forme. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>@qui = &lt;PROCWHO&gt;;
  </PRE></DIV></DIV>
<H3>Afin de créer une liste dans laquelle chaque élément correspondra à une 
ligne de la commande qui a été associée à la procédure en question (who dans le 
cas qui nous intéresse). </H3>
<H3>En sortie. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>open (IMPRIME, "|lpr Babaorum");
  </PRE></DIV></DIV>
<H3>IMPRIME est une procédure d'écriture à laquelle sera soumis le paramètre qui 
doit être retransmis à la commande lpr.<BR>A noter le pipe (|) à gauche du lpr 
et qui indique au langage que "lpr" n'est pas un nom de fichier mais une 
commande à exécuter.<BR>L'appel de cette procédure se fait sous la forme. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>print LPR @tableau;
close (LPR)
  </PRE></DIV></DIV>
<H3>Remarque.<BR>Dans le cas de IMPRIME, l'instruction "close (IMPRIME);" ferme 
le fichier après que la dernière l'information y ait été écrite. Comme la 
requète s'exécute en parallèle avec le programme, la présence de l'instruction 
de fermeture contraint Perl à terminer l'impression avant de 
poursuivre.<BR>L'ouverture d' un processus gestionnaire de fichier en écriture 
provoque la redirection de la sortie standard. Le processus partage alors la 
sortie standard et la sortie erreur avec Perl.<BR>Il n'est pas interdit 
d'effectuer la redirection dans le style unix au moyen de "&gt;", Toutefois, 
Perl propose une façon originale d'effectuer les redirections en sortie (stdout 
et stderr). </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>open (LPR, "|lpr Babaorum &gt;/dev/null 2&gt;&amp;1");
  </PRE></DIV></DIV>
<H3>La sortie standard (STDOUT) est redirigée sur /dev/null et la sortie erreur 
standard (STDERR) est redirigée sur la sortie standard STDOUT, c'est à dire en 
définitive sur /dev/null. 
<H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>open (PROCWHO, "who|");
open (LPR, "|lpr Babaorum &gt;/dev/null 2&gt;&amp;1");
while (<WHO>) {
  #L'usager chris ne veut pas apparaitre
  # dans la liste des utilisateurs.
  unless (/chris/ ) {
    print LPR $_;
  }
}
close (WHO);
close (LPR);
  </PRE></DIV></DIV>
<H2>La fonction eval().</H2>
<H3>La fonction eval (); permet d'évaluer une chaine de caractères comme si elle 
représentait un programme Perl. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme unix5.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$prog = "print (\"Impression d'une ligne \\n\");";
eval $prog;
    </PRE></TD>
    <TD class=prog><PRE>coruscant:~ chris$ perl unix5.pl<SPAN class=rouge>ent</SPAN>
Impression d'une ligne
coruscant:~ chris$
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme unix6.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
print ("Entrez une expression arithmétique :\n");
chop ($expr = <STDIN>);
print ("L'évaluation de $expr\n");
$result = eval ($expr);
print ("Donne le résultat $result"
    </PRE></TD>
    <TD class=prog><PRE>coruscant:~ chris$ perl unix6.pl<SPAN class=rouge>ent</SPAN>
Entrez une expression arithmétique :
(45+10)*3+200
L'évaluation de (45+10)*3+200
Donne le résultat 365
coruscant:~ chris$
    </PRE></TD></TR></TBODY></TABLE>
<H2>La fonction crypt().</H2>
<H3>Cette fonction va permettre le cryptage d'une chaine en utilisant 
l'algorithme NBS Data Encryption Standard. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>$resultat_crypte = crypt($ligne, $sel);
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme unix7.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
print ("Donnez moi un mot de passe : \n");
chop ($mot_de_passe = <STDIN>);
print ("Donnez moi une clé de codage : \n");
chop ($cle = <STDIN>);
$resultat = (crypt ($mot_de_passe,$cle));
print ("\nLe mot de passe '$mot_de_passe',\n");
print ("codé au moyen de la clée '$cle',\n");
print ("produit la chaine : '$resultat'.\n");
    </PRE></TD>
    <TD class=prog><PRE>coruscant:~ chris$ perl unix7.pl<SPAN class=rouge>ent</SPAN>
Donnez moi un mot de passe :
Il fait beau.
Donnez moi une clé de codage :
Soleil

Le mot de passe 'Il fait beau.',
codé au moyen de la clée 'Soleil',
produit la chaine : 'SoVR3M3EVnF0c'.
coruscant:~ chris$
    </PRE></TD></TR></TBODY></TABLE>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Formats.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Unix_fichiers/prec.gif"> 
</A>Précédent </DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Clones.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Unix_fichiers/suiv.gif"> 
</A></DIV></H2></H3></H3></BODY></HTML>
