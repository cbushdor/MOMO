<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://www.dil.univ-mrs.fr/~chris/Perl/Fichiers.htm -->
<HTML><HEAD><TITLE>Cours Perl, Les fichiers.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, Les fichiers_fichiers/Messtyles.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Les fichiers.</H1>
<H2>Rappels.</H2>
<H3>Nous avons déjà abordé ce problème. nous alllons y revenir et détailler un 
peu plus certaines particularités.<BR>Rappelons l'existence de l'opérateur 
diamand qui a souvent été utilisé pour des programmes de démonstration.<BR>Le 
nom du fichier concerné doit être stocké dans la liste spéciale prédéfinie 
@ARGV.<BR>Cette opération pouvant se faire au moyen d'une affectation. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog>@ARGV = ("monfichier.txt","donnees.txt","valeurs.txt"); 
</DIV></DIV>
<H3>0u bien en utilisant la liste d'appel de la ligne de commande.<BR>Si la 
liste contient plusieurs fichiers, on accèdera ligne par ligne au premier,puis 
on passera au suivant et ainsi de suite jusqu'à épuisement de la liste.<BR>Le 
descripteur de l'opérateur diamand est &lt;&gt; (d'où son nom) </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>@ARGV = ("entree.txt");
while ($ligne = &lt;&gt;){
  print("$ligne");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich1.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier entree.txt
Ligne 2 du fichier entree.txt
Ligne 3 du fichier entree.txt
Ligne 4 du fichier entree.txt
Ligne 5 du fichier entree.txt
Ligne 6 du fichier entree.txt
Ligne 7 du fichier entree.txt
Ligne 8 du fichier entree.txt
Ligne 9 du fichier entree.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>@ARGV = ("e1.txt","e2.txt");
while ($ligne = &lt;&gt;){
  print("$ligne");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich2.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier e1.txt
Ligne 2 du fichier e1.txt
Ligne 3 du fichier e1.txt
Ligne 4 du fichier e1.txt
Ligne 5 du fichier e1.txt
Ligne 1 du fichier e2.txt
Ligne 2 du fichier e2.txt
Ligne 3 du fichier e2.txt
Ligne 4 du fichier e2.txt
Ligne 5 du fichier e2.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Par ailleurs, l'utilisation de la variable standard d'entrée permet de 
simplifier à l'extrème l'accés à un fichier. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>while (&lt;&gt;){
  print;
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich3.pl entree.txt<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier entree.txt
Ligne 2 du fichier entree.txt
Ligne 3 du fichier entree.txt
Ligne 4 du fichier entree.txt
Ligne 5 du fichier entree.txt
Ligne 6 du fichier entree.txt
Ligne 7 du fichier entree.txt
Ligne 8 du fichier entree.txt
Ligne 9 du fichier entree.txt
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>L'accés simultané à plusieurs fichiers en lecture ou/et en écriture, 
nécessite de passer par des descripteurs explicites. </H3>
<H3>L'opérateur diamand est extrèmement utile lorsque les données sont à lire 
sur un seul fichier et sont exclusivement accessibles en lecture.<BR>Pour 
pouvoir accéder simultanément à plusieurs fichiers en lecture ou/et en écriture, 
il est nécessaire se passer par des descripteurs explicites. 
<H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Opération.</TH>
    <TH>Instruction.</TH></TR>
  <TR>
    <TD>Ouverture d'un fichier en lecture.</TD>
    <TD>open (DESC, "nom");</TD></TR>
  <TR>
    <TD>Ouverture d'un fichier en écriture.</TD>
    <TD>open (DESC, "nom");</TD></TR>
  <TR>
    <TD>Ouverture d'un fichier en écriture incrémentale </TD>
    <TD>open (DESC, "&gt;&gt;nom");</TD></TR>
  <TR>
    <TD>Ouverture d'un fichier en lecture / écriture.</TD>
    <TD>open (DESC, "+&gt;nom");</TD></TR>
  <TR>
    <TD>Fermeture d'un fichier.</TD>
    <TD>close (DESC);</TD></TR></TBODY></TABLE>
<H3>DESC est le nom du descripteur qui va désormais permettre d'accéder au 
fichier en question.<BR>"nom" est la chaîne de caractères indiquant le nom du 
fichier.<BR>Lorsqu'on ouvre un fichier en écriture, le fichier, qu'il existe ou 
nom, est détruit et l'écriture commence au début.<BR>Lorsqu'on ouvre un fichier 
en lecture incrémentale, les écritures commencent à la fin du fichier existant. 
toutes les informations qu'il contient sont ainsi conservées.<BR>Exemples : 
</H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme</TH>
    <TH>Commentaire</TH></TR>
  <TR>
    <TD>open (ENTREE, 
      "donnees.txt");<BR>while(&lt;ENTREE&gt;){<BR>print;<BR>}<BR>close(ENTREE); 
    </TD>
    <TD>Ouverture du fichier "donnees.txt" en lecture et accés séquentiel à 
      ses informations. </TD></TR>
  <TR>
    <TD>open (SORTIE, "resultats.txt");<BR>for ($i=1;$i&lt;=100;$i++) 
      {<BR>print SORTIE ("$i/n");<BR>}<BR>close(SORTIE); </TD>
    <TD>Ouverture du fichier "résultat.txt" en écriture et écriture 
      séquentielle. A la fin, le fichier contiendra les 100 premiers entiers à 
      raison de 1 par ligne. </TD></TR></TBODY></TABLE>
<H2>La fonction die().</H2>
<H3>C'est une fonction qui va permettre la récupération d'une erreur sur un 
fichier et la transmission d'un message d'alerte.<BR>Savoir si l'opération 
demandée sur un fichier a été couronnée de succés pourrait se faire de la 
manière suivante : </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>unless ( open (FICHIER, "/tmp/fichier")) {
  print "Desole, impossible d'acceder a /tmp/fichier.\n";
} else {
  # Deroulement normal du programme.
}
  </PRE></DIV></DIV>
<H3>L'ouverture renvoyant la valeur 'vrai' si l'opération s'est bien passée, 
'faux' dans le cas contraire.<BR>Perl propose, pour réaliser cette opération, 
une fonction plus pratique d'utilisation, la fonction die(). </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>unless ( open (FICHIER, "/tmp/fichier")) {
  die "Desole, impossible d'acceder a /tmp/fichier.\n";
}
# Deroulement normal du programme.
  </PRE></DIV></DIV>
<H3>Ou plus simplement en utilisant l'évaluation en court circuit des 
expressions logiques. </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>open (FICHIER, "/tmp/fichier") or
  die "Desole, impossible d'acceder a /tmp/fichier.\n"
  </PRE></DIV></DIV>
<H3>Une phrase de L. Wall résumede manière quelque peu provocatrice l'action de 
la commande die. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>"Open that file or die " </TH></TR></TBODY></TABLE>
<H3>La commande die possède une particularité intéressante.<BR>La chaîne de 
caractères qui lui est soumise pour impression peut se terminer ou ne pas se 
terminer par un \n.<BR>C'est ce caractère qui influera sur le contenu du message 
qui sera finalement affiché.<BR>Si le \n n'est pas présent à la fin de la 
chaîne, un message indiquant le nom du programme Perl qui a généré l'erreur et 
le numéro de la ligne contenant le die incriminé sera affiché à la suite de la 
chaîne en question. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme die1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>open (FICH,"toto") or
  die "erreur d\'ouverture.";
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl die1.pl<SPAN class=rouge>ent</SPAN>
# erreur d'ouverture.
File 'die1.pl'; Line 1
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Dans le cas contraire, seul le message demandé sera présenté. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme die1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>open (FICH,"toto") or
  die "erreur d\'ouverture.\n";
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl die1.pl<SPAN class=rouge>ent</SPAN>
# erreur d'ouverture.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Nous détaillerons ultérieurement d'autres particularité de cette fonction 
qui permet de terminer un programme en imprimant un message d'erreur. </H3>
<H2>La fonction select().</H2>
<H3>C'est une fonction qui va permettre de spécifier la sortie par défaut lors 
d'une opération d'entrée sortie. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich4.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl
open (FICHIER,"&gt;Sortie.txt");
$chaine = "Perl est vraiment un super langage.";
&amp;ecrire_une_ligne;
select (FICHIER);
&amp;ecrire_une_ligne;
close (FICHIER);

# Declaration procedure.
sub ecrire_une_ligne {
  print ("J'écris :\n");
  print ("$chaine\n");
  print (" sur le fichier de sortie.\n");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich4.pl<SPAN class=rouge>ent</SPAN>
J'écris :
Perl est vraiment un super langage.
sur le fichier de sortie.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Regardons maintenant le contenu di fichier "Sortie.txt" </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich4bis.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>@ARGV = ("Sortie.txt");
while (&lt;&gt;){
  print;
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich4bis.pl<SPAN class=rouge>ent</SPAN> 
J'écris :
Perl est vraiment un super langage.
sur le fichier de sortie
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Explications :<BR>La procédure écrit une ligne sur le périphérique standard 
de sortie &lt;STDOUT&gt;.<BR>Avant l'instruction "select (FICHIER);", le message 
apparait bien sur l'écran qui est toujours le périphérique de sortie 
standard.<BR>Par contre, l'exécution de cette instruction effectue une 
redirection de &lt;STDOUT&gt; vers le fichier explicitement spécifié. La seconde 
écriture se fait sur le fichier en question.<BR>Utilisé entant que fonction "$s 
= select (FICHIER);" elle permet de récupérer dans la variable le descripteur 
qui vient d'être remplacé. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>    select (SORTIE);
    . . . .
    my $ancien_desc = select (FICHIER);
</PRE></DIV></DIV>
<H3>Permet de récupérer dans le scalaire "$ancien_desc" le descripteur vers 
lequel était précédemment redirrigé la sortie tout en procédant à une nouvelle 
redirection.<BR>Il sera ainsi possible au moyen de l'instruction </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog>select ($ancien_desc); </DIV></DIV>
<H3>De revenir en arrière. </H3>
<H2>Les redirections.</H2>
<H3>Il est aussi possible de redirriger tous les fichiers standards. Ainsi, la 
rédéfinition des descripteurs &lt;STDIN&gt;, &lt;STDOUT&gt; et &lt;STDERR&gt; 
est parfaitement licite. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog>open (STDOUT,"&gt;sortie.txt"); </DIV></DIV>
<H3>Permet d'effectuer une redirection du descripteur vers le fichier 
spécifié.<BR>Toutefois, selon les systèmes utilisés, les redirections peuvent 
reserver quelques surprises.<BR>Prenons par exemple le programme suivant : </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>#!usr/bin/perl
open (STDOUT,"&gt;sortie.txt") || die ("Pas moyend'ouvrir STDIN");
open (STDERR,"&gt;STDOUT") || die ("Pas moyen d'ouvrir STDERR");
print STDOUT ("La première ligne, va sur la sortie (STDOUT).\n");
print STDERR ("La seconde ligne, va sur la sortie erreur(STDERR).\n");
close (STDOUT);
close (STDERR);
  </PRE></DIV></DIV>
<H3>Il redirrige simultanément la sortie &lt;STDOUT&gt; vers un fichier 
(sortie.txt) et la sortie &lt;STDERR&gt; vers &lt;STDOUT&gt;, soit le même 
fichier.<BR>Selon qu'on l'exécute sous un système Unix ou sous unautre système, 
les résultats seront quelque peu différents.<BR>Sous certains systèmes 
d'exploitation, le fichier sortie.txt contient :</FONT> </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>La première ligne, va sur la sortie (STDOUT).
La seconde ligne, va sur la sortie erreur(STDERR).
  </PRE></DIV></DIV>
<H3>Ce qui n'est pas trop surprenant.<BR>Sous Unix, le fichier sortie.txt 
contient : </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>La seconde ligne, va sur la sortie erreur(STDERR).
La première ligne, va sur la sortie (STDOUT).
  </PRE></DIV></DIV>
<H3>Et ca, c'est réellement une surprise qui mérite une explication. 
<BR>Manifestement, la première instruction redirige la sortie standard 
(&lt;STDOUT&gt;) vers le fichier que nous avons apelé sortie.txt.<BR>De manière 
tout aussi évidente, la seconde instruction redirige la sortie erreur 
(&lt;STDERR&gt;) vers la sortie standard (&lt;STDOUT&gt;) soit en définitive 
vers la fichier sortie.txt.<BR>L'inversion des lignes vient de la manière dont 
unix gére ses accés.<BR>L'accés à un fichier, sortie.txt par exemple, se fait 
par l'intermédiaire d'un buffer, et la copie physique sur le fichier n'a lieu 
que lorsque le buffer est plein ou lorsque le programme se termine.<BR>Bien 
qu'ils soient en fin de compte redirrigés vers la même destination, les buffers 
que le système utilise pour &lt;STDOUT&gt; et &lt;STDERR&gt; sont physiquement 
différents.<BR>La première ligne est stockée dans la zone correspondant à 
&lt;STDOUT&lt;&gt; la alors que la seconde ligne est stockée dans celle 
correspondant à &lt;STDERR&gt;.<BR>Ce n'est qu'à la fin du programme qu'ils 
seront recopiés dans leur destination finale, le fichier sortie.txt.<BR>Et c'est 
là que se produit l'inversion car Unix commence toujours par recopier le buffer 
correspondant à &lt;STDERR&gt; avant de procéder à la même opération pour pour 
celui correspondant à &lt;STDOUT&gt;. </H3>
<H2>La non bufferisation.</H2>
<H3>Le seul moyen de s'affranchir de ce problème consiste à supprimer la 
bufferisation des sorties.<BR>Nous disposons pour celà d'une variable prédéfinie 
(une de plus) à laquelle doit être assignée une valeur différente de zéro si on 
désire supprimer la bufferisation desdonnées.<BR>Son action porte sur 
&lt;STDOUT&gt; ou sur le dernier fichier spécifié par une sélection 
(select).<BR>Le nom de cette variable est $|. </H3>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>#!usr/bin/perl
open (STDOUT,"&gt;sortie.txt") || die ("Pas moyen d'ouvrirSTDIN");
open (STDERR,"&gt;&amp;STDOUT") || die ("Pas moyend'ouvrir STDERR");
select (STDERR);
# Suppression de la bufferisation de STDERR.
$| = 1;
select (STDOUT);
# Suppression de la bufferisation de STDOUT.
$| = 1;
print STDOUT ("La première ligne, va sur la sortie (STDOUT).\n");
print STDERR ("La seconde ligne, va sur la sortie erreur(STDERR).\n");
close (STDOUT);
close (STDERR);
close (STDERR);
  </PRE></DIV></DIV>
<H3>Dans ces conditions, une exécution sous Unix, stockera dans le fichier 
sortie.txt : </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>La première ligne, va sur la sortie (STDOUT).
La seconde ligne, va sur la sortie erreur(STDERR).
  </PRE></DIV></DIV>
<H2>Purge d'un descripteur.</H2>
<H3>Nous verrons plus loin, lorsqu'il sera question de communication entre les 
processus, qu'il est parfois nécessaire de purger un descripteur.<BR>La fonction 
select permet d'effectuer simplement cette opération. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>my $ancien = select (FICHIER); $| =1; select ($ancien);
my $ancien = select (SORTIE); $| =1; select ($ancien);
  </PRE></DIV></DIV>
<H3>Permet d'effectuer la purge des deux buffers liés aux descripteurs 
&lt;FICHIER&gt; et &lt;SORTIE&gt;. </H3>
<H2>La fonction eof.</H2>
<H3>Cette fonction retournera une valeur différente de Zéro lorsque la fin de 
fichier aura été atteinte. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich5.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl
@ARGV = ("Fichier1.txt", "Fichier2.txt");
while ($ligne = &lt;&gt;) {
  print ("$ligne");
  if (eof) {
    print ("\n -- Fin du fichier courant --\n");
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich5.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier 1.
Ligne 2 du fichier 1.
Ligne 3 du fichier 1.
Ligne 4 du fichier 1.
Ligne 5 du fichier 1.
Ligne 6 du fichier 1.
Ligne 7 du fichier 1.
Ligne 8 du fichier 1.
Ligne 9 du fichier 1.

-- Fin du fichier courant --

Ligne 1 du fichier 2.
Ligne 2 du fichier 2.
Ligne 3 du fichier 2.
Ligne 4 du fichier 2.
Ligne 5 du fichier 2.
Ligne 6 du fichier 2.
Ligne 7 du fichier 2.
Ligne 8 du fichier 2.
Ligne 9 du fichier 2.

-- Fin du fichier courant --
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Il existe deux fonctions eof et eof().<BR>Nous avons vu ci dessus la 
fonction eof, voyons maintenant un exemple de eof(). </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich6.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl
@ARGV = ("Fichier1.txt", "Fichier2.txt");
while ($ligne = &lt;&gt;) {
  print ("$ligne");
  if (eof()) {
    print ("\n -- Fin du fichier courant --\n");
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich6.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 du fichier 1.
Ligne 2 du fichier 1.
Ligne 3 du fichier 1.
Ligne 4 du fichier 1.
Ligne 5 du fichier 1.
Ligne 6 du fichier 1.
Ligne 7 du fichier 1.
Ligne 8 du fichier 1.
Ligne 9 du fichier 1.

Ligne 1 du fichier 2.
Ligne 2 du fichier 2.
Ligne 3 du fichier 2.
Ligne 4 du fichier 2.
Ligne 5 du fichier 2.
Ligne 6 du fichier 2.
Ligne 7 du fichier 2.
Ligne 8 du fichier 2.
Ligne 9 du fichier 2.

-- Fin du fichier courant --
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Explication :<BR>La fonction "eof" passe à vrai à la fin de chacun des 
fichiers de la liste d'appel (@ARGV), alors que la fonction "eof()" ne passe a 
vrai qu'une fois et une seule à l'épuisement de la liste d'appel. </H3>
<H2>Passage de noms de fichiers.</H2>
<H3>Il est possible de passer les noms de fichiers en tant que paramètres. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme fich7.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl   
sub ouvrir_fichier {
  my ($ref, $sens, $nom) = @_;
  open ($ref, $sens.$nom) or
    die ("Erreur ouverture $nom\n")
}

sub lire_fichier {
  my ($ref) = @_;
  &lt;$ref&gt;;
}

sub ecrire_fichier {
  my ($ref, $ligne) = @_;
  print $ref ($ligne);
}

print ("Nom du fichier à lire ?\n");
$nom_fichier = &lt;STDIN&gt;;
&amp;ouvrir_fichier ("ENTREE", "", $nom_fichier);
print("Nom du fichier aeécrire ?\n");
$nom_du_fichier = &lt;STDIN&gt;;
&amp;ouvrir_un_fichier ("SORTIE", "&gt;",$nom_fichier);
$num = 1;
while ($ligne = &amp;lire_fichier("ENTREE")) {
  print ("Traitement de la ligne $num.\n");
  $num++;
  &amp;ecrire_fichier("SORTIE", $ligne);
}
print("\nFin du programme.\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl fich7.pl<SPAN class=rouge>ent</SPAN>
Nom du fichier à lire ?
Poeme.txt<SPAN class=rouge>ent</SPAN>
Nom du fichier a ecrire ?
Sortie.txt<SPAN class=rouge>ent</SPAN>
Traitement de la ligne 1.
Traitement de la ligne 2.
Traitement de la ligne 3.
Traitement de la ligne 4.
Traitement de la ligne 5.
Traitement de la ligne 6.
Traitement de la ligne 7.
Traitement de la ligne 8.
Traitement de la ligne 9.
Traitement de la ligne 10.
Traitement de la ligne 11.
Traitement de la ligne 12.
Traitement de la ligne 13.
Traitement de la ligne 14.
Traitement de la ligne 15.
Traitement de la ligne 16.
Traitement de la ligne 17.

Fin du programme.

c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Les fonctions seek() et tell().</H2>
<H3>Une autre particularité de Perl est la possibilité qu'il offre de pouvoir 
sauter des information ou bien de procéder à leur relecture.<BR>Les deux 
fonctions seek() et tell () sont à notre disposition pour effectuer ces 
opérations.<BR>La fonction seek va permettre de sauter des caractères d'un 
fichier donné.<BR>La fonction tell va permettre de récuperer la distance (en 
caractères qui sépare le début du fichier de la position courante dans le 
fichier.<BR>La position courante est l'emplacement de la ligne qui est sur le 
point d'être lue.<BR><BR>La syntaxe de la fonction seek est la suivante : </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog>seek (référence, distance, relativement_a); </DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TD>référence</TD>
    <TD>Référence du fichier concerné.</TD></TR>
  <TR>
    <TD>distance</TD>
    <TD>Entier représentant le nombre de caractères à sauter</TD></TR>
  <TR>
    <TD>relativement_a</TD>
    <TD>Entier égal à 0, 1 ou 2.<BR>0 : relativement au début du fichier.<BR>1 
      : relativement à la prochaine ligne qui doit être lue.<BR>2 : relativement 
      à la fin du fichier.<BR></TD></TR></TBODY></TABLE>
<H3>Ainsi : </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>L'instruction.</TH>
    <TH>Provoque.</TH></TR>
  <TR>
    <TD>seek (REF,0,0)</TD>
    <TD>Un retour au début du fichier.</TD></TR>
  <TR>
    <TD>seek (REF,100,1)</TD>
    <TD>Un saut de 100 caractères en avant.</TD></TR>
  <TR>
    <TD>seek (REF,-100,1)</TD>
    <TD>Un saut de 100 caractères en arrière.</TD></TR>
  <TR>
    <TD>seek (REF,0,2)</TD>
    <TD>Un positionnement en fin de fichier.</TD></TR></TBODY></TABLE>
<H3>La syntaxe de la fonction tell est la suivante : </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog>tell (référence); </DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TD>référence</TD>
    <TD>Référence du fichier concerné.</TD></TR></TBODY></TABLE>
<H3>Attention, seek et tell ne peuvent en aucun cas être utilisés sur des 
fichiers qui font référence à des tubes. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>c:\progs&gt; type fich8.pl<SPAN class=rouge>ent</SPAN>
#!/usr/bin/perl
@liste_de_chiffres = ("zéro","un","deux","trois","quatre",
"cinq","six","sept","huit","neuf");
# Creation du fichier.
open (FICHIER, "&gt;Sortie.txt");
foreach $chiffre (@liste_de_chiffres) {
  print FICHIER ("$chiffre.\n");
}
close (FICHIER);
open (FICHIER, "Sortie.txt");
while (1) {
  $memorise = tell (FICHIER);
  $ligne= &lt;FICHIER&gt;;
  last if ($ligne eq "");
  print ("Lecontenu de la ligne est : $ligne");
  $ligne = &lt;FICHIER&gt;;
  print ("Le contenu de la ligne est : $ligne");
  print ("-retour à la position mémorisée ($memorise).\n");
  seek (FICHIER,$memorise_la_position, 0);
  $ligne = &lt;FICHIER&gt;;
  print ("Lecontenu de la ligne est : $ligne");
  $ligne = &lt;FICHIER&gt;;
  print ("Le contenu de la ligne est : $ligne");
}
c:\progs&gt;perl fich8.pl<SPAN class=rouge>ent</SPAN>
Le contenu de la ligne est : zéro.
Le contenu de la ligne est : un.
- retour à la position mémorisée (0).
Le contenu de la ligne est : zéro.
Le contenu de la ligne est : un.
Le contenu de la ligne est : deux.
Le contenu de la ligne est : trois.
- retour à la position mémorisée (10).
Le contenu de la ligne est : deux.
Le contenu de la ligne est : trois.
Le contenu de la ligne est : quatre.
Le contenu de la ligne est : cinq.
- retour à la position mémorisée (23).
Le contenu de la ligne est : quatre.
Le contenu de la ligne est : cinq.
Le contenu de la ligne est : six.
Le contenu de la ligne est : sept.
- retour à la position mémorisée (37).
Le contenu de la ligne est : six.
Le contenu de la ligne est : sept.
Le contenu de la ligne est : huit.
Le contenu de la ligne est : neuf.
- retour à la position mémorisée (48).
Le contenu de la ligne est : huit.
Le contenu de la ligne est : neuf.
c:\progs&gt;
  </PRE></DIV></DIV>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Specificites.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Les fichiers_fichiers/prec.gif"> 
</A>Précédent </DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Formats.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Les fichiers_fichiers/suiv.gif"> 
</A></DIV></H2></H3></H3></BODY></HTML>
