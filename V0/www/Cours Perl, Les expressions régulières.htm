<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0048)http://www.dil.univ-mrs.fr/~chris/Perl/Regex.htm -->
<HTML><HEAD><TITLE>Cours Perl, Les expressions régulières.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, Les expressions régulières_fichiers/Messtyles.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Les expressions régulières.</H1>
<H2>Définition. </H2>
<H3>Une expression régulière est constituée d'un modèle (un gabarit) que l'on va 
tenter d'assortir à une chaine.<BR>La comparaison, couronnée ou non de succés, 
pourra conduire à prendre une décision ou à accomplir une action.<BR>Afin de 
présenter quelques exemples sous leur forme la plus simple, nous allons utiliser 
le fichier suivant (entree.txt). </H3>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>c:\progs&gt; type entree.txt<SPAN class=rouge>ent</SPAN>
Ligne 1 contenant la chaine aaa
Ligne 2 contenant la chaine bbb
Ligne 3 contenant la chaine aaabbb
Ligne 4 contenant la chaine bbaaabb
Ligne 5 contenant la chaine aaaaaa
Ligne 6 contenant la chaine ababab
Ligne 7 contenant la chaine bbaabb
Ligne 8 contenant la chaine aaaa
Ligne 9 contenant la chaine aa
c:\progs&gt;
  </PRE></DIV></DIV>
<H3>Les modèles que nous tenterons de mettre en évidence seront des suites de a 
et de b. </H3>
<H2>Un premier exemple. </H2>
<H3>Un exemple simple valant mieux qu'un long discours, nous allons en commenter 
un. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV = ("Entree.txt");
while (&lt;&gt;) {
  if (/aaa/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg1.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 contenant la chaine aaa
Ligne 3 contenant la chaine aaabbb
Ligne 4 contenant la chaine bbaaabb
Ligne 5 contenant la chaine aaaaaa
Ligne 8 contenant la chaine aaaa
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment>@ARGV = ("Entree.txt"); </TD>
    <TD class=comment>Déclaration du fichier "entrée.txt en tant que source de 
      l'opérateur diamand. </TD></TR>
  <TR>
    <TD class=comment>while (&lt;&gt;) { </TD>
    <TD class=comment>Accés aux lignes successives du fichier et test de fin 
      de fichier. Aucun scalaire n'étant spécifié en tant de destination, les 
      lignes seront stockées dans la variable scalaire standard $_. </TD></TR>
  <TR>
    <TD class=comment>if (/aaa/) { </TD>
    <TD class=comment>La condition se présente entre deux slash (/) indiquant 
      qu'il s'agit d'une expression régulière. Il n'y a aucune indication à 
      propos du scalaire qui contient la chaîne de caractères sur laquelle doit 
      porter le recherche, ce sera donc par définition la variable scalaire 
      standard $_. Le modèle que l'on recherche est une suite de trois fois le 
      caractère "a". Si ce modèle est trouvé, alors la réponse sera 'vrai', dans 
      le cas contraire, elle sera 'faux'. </TD></TR>
  <TR>
    <TD class=comment>print "$_"; </TD>
    <TD class=comment>Si la réponse est 'vrai', c'est à dire que le modèle 
      recherché est présent dans la chaîne de référence, on imprime la ligne en 
      question. </TD></TR>
  <TR>
    <TD class=comment>} </TD>
    <TD class=comment>Sinon on se contente de passer à la ligne suivante. 
  </TD></TR>
  <TR>
    <TD class=comment>} </TD>
    <TD class=comment>Jusqu'à épuisement des lignes du fichier d'entrée. 
  </TD></TR></TBODY></TABLE>
<H2>Le facteur multiplicatif (*).</H2>
<H3>Une astérisque (*) située immédiatement derrière un caractère permet 
d'indiquer que ce caractère peut se présenter de 0 à n fois. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>ab*a
  </PRE></DIV></DIV>
<H3>Est un modèle qui reonnaitra toutes les cibles de type. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment>aa </TD>
    <TD class=comment>Zéro "b" entre deux "a" </TD></TR>
  <TR>
    <TD class=comment>aba </TD>
    <TD class=comment>Un "b" entre deux "a" </TD></TR>
  <TR>
    <TD class=comment>abba </TD>
    <TD class=comment>Deux "b" entre deux "a" </TD></TR>
  <TR>
    <TD class=comment>ab....ba </TD>
    <TD class=comment>n "b" entre deux "a" </TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV = ("Entree");
while (&lt;&gt;) {
  if (/ab*b/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg2.pl<SPAN class=rouge>ent</SPAN>
igne 3 contenant la chaine aaabbb
Ligne 4 contenant la chaine bbaaabb
Ligne 6 contenant la chaine ababab
Ligne 7 contenant la chaine bbaabb
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>La recherche porte sur un modèle comportant un "a" suivi de 0 à n fois un 
"b" suivi de un b. en résumé, un "a" suivi de au moins un "b". </H3>
<H2>Modification de la cible. </H2>
<H3>Une fois le modèle trouvé, il est possible de procéder à une modification de 
la cible. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV = ("Entree");
while (&lt;&gt;) {
  if (s/ab*b/XXXX/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg3.pl<SPAN class=rouge>ent</SPAN>
Ligne 3 contenant la chaine aaXXXX
Ligne 4 contenant la chaine bbaaXXXX
Ligne 6 contenant la chaine XXXXabab
Ligne 7 contenant la chaine bbaXXXX
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Le modèle que l'on recherche est le même que celui vu à l'exercice 
précédent. Mais ici on ne se contente pas de le mettre en évidence. On lui 
substitue une autre chaîne, dans l'exemple, la chaîne "xxxx".<BR>L'écriture de 
l'expression régulière fait apparaître trois champs.<BR>s pour substitute, 
indique que l'on procèdera à une substitution.<BR>/ab*b/ le modèle 
recherché.<BR>/xxxx/ les caractères qui seront substitués au modèle une fois ce 
dernier détecté. </H3>
<H2>Les jokers et les ensembles.</H2>
<H3>Le caractère point (.) s'assortira à n'importe quel caractère, exeption 
faite du \n (fin de ligne) </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>/a.b/
  </PRE></DIV></DIV>
<H3>Recherche tout groupe de trois caractères dont le premier est un "a", et le 
troisième un "b" sans plus de précisions concernant le troisième, sinon que ce 
n'est surement pas un \n.<BR></H3>
<H3>Il est possible de spécifier ensemble de caractère afin de rechercher un 
caractère qui en fait partie. Cet ensemble sera représenté par la liste de ses 
composantes encadreé de crochets. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>/b[aeiou]b/
  </PRE></DIV></DIV>
<H3>Recherche un des elements de l'ensemble (une voyelle) comprise entre deux 
"b" </H3>
<H3>Il est aussi possible de complémenter l'ensemble. Le caractère "^" présent 
au debut de l'ensemble indique que l'on souhaite rechercher un caractère ne 
faisant pas partie de l'ensemble en question. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>/b[^aeiou]b/
  </PRE></DIV></DIV>
<H3>Recherche deux "b" encadrant un caractère qui peut être n'importe quoi sauf 
une voyelle. </H3>
<H3>Les ensembles de caractères consécutifs peuvent se présenter sous une forme 
raccourcie, laissant au systéme le soin de le développer. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>[0-9]</TD>
    <TD>L'ensemble des caractères compris entre 0 et 9.</TD></TR>
  <TR>
    <TD>[a-z]</TD>
    <TD>L'ensemble des lettres minuscules.</TD></TR>
  <TR>
    <TD>[A-Z]</TD>
    <TD>L'ensemble des lettres majuscules.</TD></TR></TBODY></TABLE>
<H2>Les classes prédéfinies. </STRONG></FONT>
<P></P>
<H3>Les ensembles que nous venons de voir sont d'une grande utilité, ils nous 
permettent de définir des classes de caractères spécifiques. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>[0-9]</TD>
    <TD>Les chiffres.</TD></TR>
  <TR>
    <TD>[^0-9]</TD>
    <TD>Tout sauf un chiffre.</TD></TR>
  <TR>
    <TD>[a_zA-Z0-9_]</TD>
    <TD>L'ensemble des caractères utilisables pour représenter des 
      identificateurs.</TD></TR>
  <TR>
    <TD>[^a_zA-Z0-9_]</TD>
    <TD>Tout caractère sauf ceux utilisé pour représenter des 
    identificateurs.</TD></TR></TBODY></TABLE>
<H3>Afin de simplifier l'écriture des expressions régulières, certaines de ces 
classes sont prédéfinies. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Nom de la classe</TH>
    <TH>Signification</TH>
    <TH>Classe équivalente.</TH></TR>
  <TR>
    <TD>\d</TD>
    <TD>Chiffres</TD>
    <TD>[0-9]</TD></TR>
  <TR>
    <TD>\D</TD>
    <TD>Tout sauf un chiffre</TD>
    <TD>[^0-9]</TD></TR>
  <TR>
    <TD>\w</TD>
    <TD>Caractères faisant partie de la construction des mots</TD>
    <TD>[a_zA-Z0-9_]</TD></TR>
  <TR>
    <TD>\W</TD>
    <TD>Tout sauf les caractères faisant partie de la construction des mots 
      (les séparateurs)</TD>
    <TD>[a_zA-Z0-9_]</TD></TR>
  <TR>
    <TD>\s</TD>
    <TD>Les séparateurs?</TD>
    <TD>[\t\n\f\r]</TD></TR>
  <TR>
    <TD>\S</TD>
    <TD>Tout sauf un séparateur</TD>
    <TD>[^\t\n\f\r]</TD></TR></TBODY></TABLE>
<H2>Exemple : </H2>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>/\W\d*\dA\d\W/  </PRE></DIV></DIV>
<H3>Est le modèle qui va permettre de chercher. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment>\W </TD>
    <TD class=comment>Un caractère ne faisant pas partie de ceux composant les 
      mots (séparateur ou signe de ponctuation. </TD></TR>
  <TR>
    <TD class=comment>\d* </TD>
    <TD class=comment>Suivi d'un nombre de chiffres compris entre 0 et n. 
  </TD></TR>
  <TR>
    <TD class=comment>\d </TD>
    <TD class=comment>Suivi d'un chiffre. En résumé, au moins un chiffre. 
  </TD></TR>
  <TR>
    <TD class=comment>A </TD>
    <TD class=comment>Suivi du caractère "A" (en majuscule). </TD></TR>
  <TR>
    <TD class=comment>\d </TD>
    <TD class=comment>Suivi d'un chiffre. </TD></TR>
  <TR>
    <TD class=comment>\W </TD>
    <TD class=comment>Et se terminant par un caractère ne faisant pas partie 
      de ceux composant les mots (séparateur ou signe de ponctuation. 
  </TD></TR></TBODY></TABLE>
<H3>Voici quelques cibles répondant à ce modèle. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>,12A3.
-1A1;
(123A4)
  </PRE></DIV></DIV>
<H3>Et en voici ne répondant pas à ce modèle. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>12A3.
-A1;
(123AA4)  </PRE></DIV></DIV>
<H2>Les autres facteurs multiplicatifs. </H2>
<H3>Nous avons évoqué l'astérisque, facteur multiplicatif 0 à n.<BR>Il existe 
deux autres facteurs prédéfinis.<BR>Le + représentant le facteur multiplicatif 
de 1 à n.<BR>Le ? représentant le facteur multiplicatif par 0 ou 1. </H3>
<H3>Là ne s'arrètent pas les possibilités, l'usager a toute lattitude pour 
definir explicitement ses propres facteurs multiplicatifs. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg4.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV = ("Entree");
while (&lt;&gt;) {
  if (/xy{2,3}/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg4.pl<SPAN class=rouge>ent</SPAN>
Ligne 3 contenant la chaine xxxyyy
Ligne 4 contenant la chaine yyxxxyy
Ligne 7 contenant la chaine yyxxyy
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche la chaine de caractères constituée du caractère "x" suivi d'un 
nombre de "y" compris entre 2 et 3. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg5.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV = ("Entree");
while (&lt;&gt;) {
  if (/xy{3,}/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg5.pl<SPAN class=rouge>ent</SPAN>
Ligne 3 contenant la chaine xxxyyy
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche la chaine de caractères constituée du caractère "x" suivi d'un 
nombre de "y" supérieur ou égal à 3. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg6.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV = ("Entree");
while (&lt;&gt;) {
  if (/xy{0,3}/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg6.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 contenant la chaine xxx
Ligne 3 contenant la chaine xxxyyy
Ligne 4 contenant la chaine yyxxxyy
Ligne 5 contenant la chaine xxxxxx
Ligne 6 contenant la chaine xyxyxy
Ligne 7 contenant la chaine yyxxyy
Ligne 8 contenant la chaine xxxx
Ligne 9 contenant la chaine xx 
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche la chaine de caractères constituée du caractère "x" suivi d'un 
nombre de "y" inférieur ou égal à 3. </H3>
<H2>Exemple. </H2>
<H3>Validation du nom d'une variable. </H3>
<H3>Un nom de scalaire commence par un $, immediatement suivi d' une lettre 
(majuscule ou minuscule) et se continue par un nombre quelconque de lettres 
majuscules, lettres minuscules, blancs soulignés ou chiffres. </H3>
<H3>Un nom de liste commence par un @, immediatement suivi d' une lettre 
(majuscule ou minuscule) et se continue par un nombre quelconque de lettres 
majuscules, lettres minuscules, blancs soulignés ou chiffres. </H3>
<H3>Un nom de hash commence par un %, immediatement suivi d' une lettre 
(majuscule ou minuscule) et se continue par un nombre quelconque de lettres 
majuscules, lettres minuscules, blancs soulignés ou chiffres. </H3>
<H3>Un nom de descripteur de fichier commence par une lettre (majuscule ou 
minuscule) et se continue par un nombre quelconque de lettres majuscules, 
lettres minuscules, blancs soulignés ou chiffres. </H3>
<H3>Ecrire un programme Perl qui lise un nom de variable et le valide en 
indiquant quelle forme il représente. </H3>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>c:\progs&gt; type valid.pl<SPAN class=rouge>ent</SPAN> 
#!usr/bin/perl
print "Donner un nom de variable : ";
chop (<STDIN>);
if (/\$[A-Za-z][_0-9A-Za-z]*/){
  print ("Le nom $_ représente une variable scalaire.\n";
} elsif (/@[A-Za-z][_0-9A-Za-z]*/){
   print ("Le nom $_ représente une liste.\n";
} elsif (/%[A-Za-z][_0-9A-Za-z]*/){
   print ("Le nom $_ représente un hash.\n";
} elsif (/[A-Za-z][_0-9A-Za-z]*/){
   print ("Le nom $_ représente un fichier.\n";
} else {
  print ("Le nom $_ ne représente par une variable.\n");
}
c:\progs&gt;
  </PRE></DIV></DIV>
<H2>Mémoriser des modèles. </H2>
<H3>Les parenthèses permettent de mémoriser une chaine de caractères qui pourra, 
de cette manière, être référencée ultérieurement. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg7.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV=("Entree");
while (&lt;&gt;) {
  if (/x(.)y\1/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg7.pl<SPAN class=rouge>ent</SPAN>
Ligne 3 contenant la chaine xxxyyy
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Dans l'exemple ci dessus, la référence \1 designe la premiere (et dans ce 
cas, la seule) forme mémorisée dans l'expression régulière. </H3>
<H3>On recherche le caractère "x" suivi d'un caractère que l'on ne comnnait pas, 
mais que l'on mémorise, lui même suivi d'un caractère "y" et se terminant par un 
caractère identique à celui qui se trouvait en seconde position et auquel on 
fait référence par son nom (\1). </H3>
<H3>Ainsi par exemple, /a(.)b(.)c\2d\1/ permet de déterminer une forme qui 
serait composée de la lettre "a" suivi d'un caractère (c1) suivi de b suivi d'un 
caractère (c2) suivi de c suivi du caractère c2 (le second mémorisé) auquel on 
fait référence par son nom (\2), suivi de d suivi du caractère c1 (le premier 
mémorisé) et auquel on fait référence par son nom (\1). </H3>
<H3>La chaine "axbycydx' est donc une cible reconnue. </H3>
<H3>Une mémoire peut contenir un modèle composé de plusiaurs caractères couvrant 
le modèle situé entre parenthèses. Ainsi, le modèle </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>/a(.*)b\1/
  </PRE></DIV></DIV>
<H3>Appliqué à la chaine </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"axxxbxxx"
  </PRE></DIV></DIV>
<H3>Mémorisera les caractères compris entre "a" et "b", c'est à dire "xxx". 
C'est cette chaîne qui sera confrontée avec celle qui suit le caractère "b" pour 
décider si oui ou non il y a coincidence. Dans ces conditions. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Pour la cible</TH>
    <TH>La réponse sera</TH></TR>
  <TR>
    <TD>axxxbxxx/td&gt; 
    <TD>vrai</TD></TR>
  <TR>
    <TD>ayybyy</TD>
    <TD>vrai</TD></TR>
  <TR>
    <TD>axxxbxx</TD>
    <TD>faux</TD></TR>
  <TR>
    <TD>axybxy</TD>
    <TD>vrai</TD></TR>
  <TR>
    <TD>ab</TD>
    <TD>vrai</TD></TR></TBODY></TABLE>
<H3>Le modèle mémorisé peut se retrouver indifférement dans la partie modèle ou 
dans la partie substitution. </H3>
<H3>Ainsi, considérons la chaîne </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"AA-aaa-BB-bbb-C-C-ccc-DD"
  </PRE></DIV></DIV>
<H3>Et soumettons la à l'expression régulière. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>s/A(.*)B(.*)C/X\1Y\2Z/
  </PRE></DIV></DIV>
<H3>On obtiendra le résultat. 
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"XA-aaa-BY-bbb-C-Z-ccc-DD"
  </PRE></DIV></DIV>
<H2>Explications</H2>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment>s/<SPAN class=rouge>A</SPAN>(.*)B(.*)C/X\1Y\2Z/ </TD>
    <TD class=comment>On cherche la lettre "A" </TD></TR>
  <TR>
    <TD class=comment>s/A<SPAN class=rouge>(.*)</SPAN>B(.*)C/X\1Y\2Z/ </TD>
    <TD class=comment>On mémorise alors la chaine qui suit le "A" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)<SPAN class=rouge>B</SPAN>(.*)C/X\1Y\2Z/ </TD>
    <TD class=comment>Et ce, jusqu'à l'ocurence du caractère "B". La première 
      mémoire \1 contient "A-aaa-B" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B<SPAN class=rouge>(.*)</SPAN>C/X\1Y\2Z/ </TD>
    <TD class=comment>On mémorise alors la chaine qui suit le "B" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)<SPAN class=rouge>C</SPAN>/X\1Y\2Z/ </TD>
    <TD class=comment>Et ce, jusqu'à l'ocurence du caractère "C". La seconde 
      mémoire \2 contient "-bbb-C-" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)C<SPAN class=rouge>/</SPAN>X\1Y\2Z/ </TD>
    <TD class=comment>On passe alors à la substition. </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)C/<SPAN class=rouge>X</SPAN>\1Y\2Z/ </TD>
    <TD class=comment>On commence par écrire la lettre "X" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)C/X<SPAN class=rouge>\1</SPAN>Y\2Z/ </TD>
    <TD class=comment>Suivie de la chaîne contenue dans la première 
      mémoire("A-aaa-B"). L'état de la chaîne à ce point est "XA-aaa-B". </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)C/X\1<SPAN class=rouge>Y</SPAN>\2Z/ </TD>
    <TD class=comment>On écrit alors le caractère "Y". La chaîne est devenue 
      "XA-aaa-BY" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)C/X\1Y<SPAN class=rouge>\2</SPAN>Z/ </TD>
    <TD class=comment>On fait alors suivre la chaîne du contenu de la seconde 
      mémoire, elle devient "XA-aaa-BY-bbb-C-" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)C/X\1Y\2<SPAN class=rouge>Z</SPAN>/ </TD>
    <TD class=comment>Et on termine l'expression régulière en écrivant un "Z" 
      pour obtenir "XA-aaa-BY-bbb-C-Z" </TD></TR>
  <TR>
    <TD class=comment>s/A(.*)B(.*)C/X\1Y\2Z/ </TD>
    <TD class=comment>Reste la fin de la chaîne (tout ce qui suit le second 
      "C" et qui n'était pas concerné. Elle ne bouge pas et reste donc à sa 
      place."XA-aaa-BY-bbb-C-Z-ccc-DD" </TD></TR></TBODY></TABLE>
<H3>La troisième ligne mérite une explication supplémentaire. Il est en effet 
nécessaire d'expliquer pourquoi le modèle </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>A(.*)B
  </PRE></DIV></DIV>
<H3>Ciblé sur la chaîne </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"A-aaa-BB"
  </PRE></DIV></DIV>
<H3>Mémorise </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"A-aaa-B"
  </PRE></DIV></DIV>
<H3>Et non pas </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"A-aaa-"
  </PRE></DIV></DIV>
<H3>Ceci provient du fait que la couverture du modèle est dite "avide". </H3>
<H3>La couverture sera toujours tirée afin de couvrir la cible maximale.<BR>Dans 
le cas qui nous interesse, les "B" successifs seront intégrés et seul le dernier 
mettra fin à la couverture. </H3>
<H3>Il est important de toujours garder ce principe à l'esprit lorsqu'on 
travaille sur les expressions régulières. &lt;:h3&gt; 
<H3>Considérons la chaîne. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"Yxxxxxxxx"
  </PRE></DIV></DIV>
<H3>A laquelle est appliqué le modèle </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>/Y(x*)/
  </PRE></DIV></DIV>
<H3>Le principe d'avidité conduit, en couvrant toujours la cible au maximum, à 
mémoriser la chaîne </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"xxxxxxxx"
  </PRE></DIV></DIV>
<H2>Les ancrages.</H2>
<H3>Il s'agit de la possibilité qui est offerte d'ancrer un modèle à un 
emplacement particulier de la cible considérée.<BR>Début de mot ou de 
chaîne.<BR>Milieu de mot ou de chaîne.<BR>Fin de mot ou de chaîne. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg8.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV=("Entree");
while (&lt;&gt;) {
  if (/xyy\b/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg8.pl<SPAN class=rouge>ent</SPAN>
Ligne 4 contenant la chaine yyxxxyy
Ligne 7 contenant la chaine yyxxyy
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche une chaine constituée des lettrex xyy ancrées en fin de mot, 
c'est à dire immédiatement suivies d'un séparateur (\b). </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg9.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV=("Entree");
while (&lt;&gt;) {
  if (/\bxxx/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg9.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 contenant la chaine xxx
Ligne 3 contenant la chaine xxxyyy
Ligne 5 contenant la chaine xxxxxx
Ligne 8 contenant la chaine xxxx
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche une chaine constituée des lettrex xyy ancrées en début de mot, 
c'est à dire immédiatement précédées d'un séparateur (\b). </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg10.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV=("Entree");
while (&lt;&gt;) {
  if (/\bxxx\b/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg10.pl<SPAN class=rouge>ent</SPAN>
Ligne 1 contenant la chaine xxx
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche une chaine constituée des lettrex xyy ancrées en début et en fin 
de mot, c'est à dire immédiatement précédées et immédiatement suivies d'un 
séparateur (\b). Soit le mot xxx. </H3>
<H3>Nous avons vu, au moment ou il a été question des classes prédéfinies qu'une 
classe était représentée en lettre minuscule alors que la classe complémentaire 
était représentée en lettre majuscule. La classe complémentaire de \b sera donc 
\B. Elle représentera tout ce qui n'est pas un séparateur. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg11.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV=("Entree");
while (&lt;&gt;) {
  if (/\bxy\B/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg11.pl<SPAN class=rouge>ent</SPAN>
Ligne 6 contenant la chaine xyxyxy
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche une chaine constituée des lettres xy ancrées en début de mot, 
c'est à dire immédiatement précédées d'un séparateur et ne constituant pas un 
mot à elles toute seules . </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg12.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
@ARGV=("Entree");
while (&lt;&gt;) {
  if (/\Bxy\B/) {
    print "$_";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg12.pl<SPAN class=rouge>ent</SPAN>
Ligne 3 contenant la chaine xxxyyy
Ligne 4 contenant la chaine yyxxxyy
Ligne 6 contenant la chaine xyxyxy
Ligne 7 contenant la chaine yyxxyy
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On cherche une chaine constituée des lettrex xy ancrées en milieu de mot, 
c'est à dire ne constituant pas un mot à elles toute seules. </H3>
<H3>Il est aussi possible d'ancrer les caractères par rapport à la chaîne cible 
en utilisant les caractères spéciaux ^et $. Il faut toutefois faire attention a 
leur emplacement dans l'expression régulière afin que leur interprétation ne 
soit pas erronée.<BR>Le caractère "^", si il est le premier caractère de 
l'expression régulière, permet d'ancrer le modèle au début de la cible.<BR>Le 
caractère "$", si il est le dernier caractère de l'expression régulière, permet 
d'ancrer le modèle à la fin de la cible. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Exemple</TH>
    <TH>Commentaire</TH></TR>
  <TR>
    <TD>/^a/</TD>
    <TD>"vrai" si la cible commence par le caractère "a".</TD></TR>
  <TR>
    <TD>/\^a/</TD>
    <TD>"vrai" si la cible contient la chaîne "^a"</TD></TR>
  <TR>
    <TD>/a^/</TD>
    <TD>"vrai" si la cible contient la chaîne "a^".</TD></TR>
  <TR>
    <TD>/a$/</TD>
    <TD>"vrai" si la cible se termine par le caractère "a".</TD></TR>
  <TR>
    <TD>/a\$/</TD>
    <TD>"vrai" si la cible contient la chaîne "a$".</TD></TR>
  <TR>
    <TD>/$a/</TD>
    <TD>"vrai" si la cible contient la chaîne "$a".</TD></TR></TBODY></TABLE>
<H3>$a permet de sélectionner la chaine "$a"Dans une expression régulière, la 
priorité des opérateurs est la suivante. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Priorité</TH>
    <TH>Opérateur</TH>
    <TH>Représentation</TH></TR>
  <TR>
    <TD>Maximale</TD>
    <TD>Parenthèses</TD>
    <TD>( )</TD></TR>
  <TR>
    <TD>.</TD>
    <TD>Multiplicateurs</TD>
    <TD>+ * ? (m,n)</TD></TR>
  <TR>
    <TD>.</TD>
    <TD>Séquences, ancrages</TD>
    <TD>abc ^ $ \b \B</TD></TR>
  <TR>
    <TD>Minimale</TD>
    <TD>choix</TD>
    <TD>|</TD></TR></TBODY></TABLE>
<H3>Ainsi, /a|b*/ ne signifie pas n fois le caractère "a" ou n fois le caractère 
"b". L'opérateur multiplicatif ayant une priorité supérieure à l'opérateur de 
choix, il sera appliqué en premier. La cible que l'on recherche sera donc un 
caractère "a" suivi de n caractères "b" (abbb..b). </H3>
<H3>Pour repérer la chaîne n fois le caractère "a" ou n fois le caractère "b", 
l'expression régulière aurait été /(a|b)*/. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Exemple</TH>
    <TH>Commentaire</TH></TR>
  <TR>
    <TD>/abc*/</TD>
    <TD>"a" suivi de "b" suivi de zéro ou plusieurs "c".</TD></TR>
  <TR>
    <TD>/(abc)* /</TD>
    <TD>0 ou n fois la chaîne "abc".</TD></TR>
  <TR>
    <TD>/^x|y/</TD>
    <TD>Un "x" en début de mot suivi de tout caractère, ou un "y" où qu'il 
      soit dans la chaine.</TD></TR>
  <TR>
    <TD>/a|bc|d/</TD>
    <TD>Toute chaine contenant le caractère "a" ou les caractères "bc" ou le 
      caractère "d".</TD></TR>
  <TR>
    <TD>/(a|b)(c|d)/</TD>
    <TD>Toute chaine contenant le caractère "a" ou le caractère "b" suivis du 
      caractère "c" ou du caractère "d" ("ac", "ad", "b"c, 
"bd").</TD></TR></TBODY></TABLE>
<H2>Les cibles.</H2>
<H3>Jusqu'à présent, nous avons considéré que la cible à laquelle on soumet le 
modèle se trouvait dans la variable d'entrée standard ($_). Dans ces conditions, 
il n'était pas nécessaire de le préciser. Si ce n'est pas le cas, c'est à dire 
si la cible se trouve dans une variable scalaire quelconque, l'opérateur =~ va 
nous permettre de soumettre l'expression régulière qui se trouve à sa droite à 
la variable scalaire spécifiée à sa gauche.<BR>Le résultat de cette opération 
est "vrai" si une concordance est trouvée, "faux" sinon. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg13.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "Bonjour";
print ("Recherche de la chaine Bo.\n");
print ("Resultat : ",$cible =~ /^Bo/);
print "\n";
print ("Recherche de la chaine ja\n");
print ("Resultat : ",$cible =~ /ja/);
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg13.pl<SPAN class=rouge>ent</SPAN>
Recherche de la chaine Bo.
Resultat : 1
Recherche de la chaine ja.
Resultat : 
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>C'est ainsi que l'on peut écrire. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>if($cible =~ /expr. régulière/) {
  Séquence pour condition vraie;
} else {
  Séquence pour condition fausse;
}
  </PRE></DIV></DIV>
<H3>A noter aussi que la partie gauche de l'opérateur =~ peut être 
&lt;STDIN&gt;. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg14.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
print ("Quelle est votre reponse ? ");
if (<STDIN> =~/^[oO]/) {
  print ("La reponse est oui.\n\n");
}
else {
  print ("La reponse est non.\n\n");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg14.pl<SPAN class=rouge>ent</SPAN>
Quelle est votre reponse ? Oui<SPAN class=rouge>ent</SPAN>
La reponse est oui.
c:\progs&gt; perl reg14.pl<SPAN class=rouge>ent</SPAN>
Quelle est votre reponse ? Non<SPAN class=rouge>ent</SPAN>
La reponse est non.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Voici à titre d'exemple quelques exercices amusants auxquels tout amateur de 
mots croisés peut se trouver confronté. </H3>
<H3>Nous avons récupéré un dictionnaire du français que nous avons stocké dans 
un fichier référencé "francais.txt". </H3>
<H3>Afin d'en faciliter l'utilisation, il ne contient aucun caractères non ascii 
sinon le trait d'union. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>a-cotea-cotes<BR>a-coup<BR>a-coups<BR>a-peu-pres<BR>a-pic<BR>a-propos<BR>a-valoir<BR>a-venir<BR>abaissa<BR>..... 
    </TD>
    <TD>.....<BR>irreformables<BR>irrefrenable<BR>irrefrenables<BR>irrefutable<BR>irrefutables<BR>irrefute<BR>irrefutee<BR>irrefutees<BR>.... 
    </TD>
    <TD>.....<BR>zoologiste<BR>zoologistes<BR>zoom<BR>zooms<BR>zoos<BR>zouave<BR>zouaves<BR>zozoter<BR>zyeuter 
    </TD></TR></TBODY></TABLE>
<H3>Livrons nous maintenant à quelques recherches. </H3>
<H3>Trouver tous les mots qui commencent par les lettres 'shu'. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/^shu/) {
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico1.pl<SPAN class=rouge>ent</SPAN>
shunter
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Trouver tous les mots qui finissent par les lettres 'ley'. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/ley$/) {
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico2.pl<SPAN class=rouge>ent</SPAN>
trolley
volley
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Trouver tous les mots qui contiennent la chaine 'aer' suivie de deux 
caractères quelconques suivi d'un 'y' </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/aer..y/) {
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico3.pl<SPAN class=rouge>ent</SPAN>
aerodynamique
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Trouver tous les mots qui contiennent l'une des trois lettres g,j ou p 
suivie des deux caractères 'er' puis de deux caractères quelconques puis d'un 
'y'. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico4.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/[gjp]er..y/) {
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico4.pl<SPAN class=rouge>ent</SPAN>
jersey
peroxyder
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Trouver tous les mots qui commencent par une lettre de l'intervalle a-d 
(a,b,c ou d) puis qui contienne les deux lettres 'hry' puis, soit une lettre 
pris dans l'intervalle a-i, soit la lettre "s". </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico5.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/^[a-d]hry[a-is]/) { 
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico5.pl<SPAN class=rouge>ent</SPAN>
chrysalide
chrysantheme
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Trouver tous les mots qui commencent par la lettre k suivie de au moins deux 
voyelles. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico6.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/^k[aeiou][aeiou][aeiou]*/){ 
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico6.pl<SPAN class=rouge>ent</SPAN>
kaolin
kiosque 
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Trouver tous les mots qui commencent par quo et se terminent par t. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico7.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
    chop ($ligne);
  if ($ligne =~/^quo[a-z]*t$/) {
  print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico7.pl<SPAN class=rouge>ent</SPAN>
quolibet
quotidiennement
quotient 
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Autre possibilité. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico8.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
      chop ($ligne);
     if ($ligne =~/^quo.*t$/) {
     print "$ligne\n";
     }
}    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico8.pl<SPAN class=rouge>ent</SPAN>
quolibet
quote-part
quotidiennement
quotient 
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Et pour finir, résoudre la vieille devinette qui consiste à trouver tous les 
mots contenant les voyelles "a", "e", "i", "o", "u" dans cet ordre, les lettres 
n'étant pas forcément adjacentes. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico9.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/[a-z]*a[a-z]*e[a-z]*i[a-z]*o[a-z]*u/) {
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico9.pl<SPAN class=rouge>ent</SPAN>
bacteriologique
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Ou bien, autre solution un peu plus générale. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme dico10.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("francais.txt");
while  ($ligne = &lt;&gt;) {
  chop ($ligne);
  if ($ligne =~/.*a.*e.*i.*o.*u/) {
    print "$ligne\n";
  }
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl dico10.pl<SPAN class=rouge>ent</SPAN>
bacteriologique
garde-chiourme
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Majuscules, minuscules.</H2>
<H3>Reprenons le programme 14 qui testait une réponse. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg14.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
print ("Quelle est votre reponse ? ");
if (<STDIN> =~/^[oO]/) {
  print ("La reponse est oui.\n\n");
}
else {
  print ("La reponse est non.\n\n");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg14.pl<SPAN class=rouge>ent</SPAN>
Quelle est votre reponse ? Oui<SPAN class=rouge>ent</SPAN>
La reponse est oui.
c:\progs&gt; perl reg14.pl<SPAN class=rouge>ent</SPAN>
Quelle est votre reponse ? Non<SPAN class=rouge>ent</SPAN>
La reponse est non.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>La réponse attendue pouvant être "Oui" ou "oui", la methode simple 
consistait à créer un ensemble compose d'un o (minuscule) et d'un O (majuscule) 
et de tester le premier caractère de la reponse. C'est ce qui est fait dans 
l'exemple.<BR>L'option "i" (pour ignore case) va nous permettre d'ignorer, sur 
l'ensemble de la cible, le fait que les caractères soient représentés en 
majuscule ou en minuscule.<BR>Les options apparaissent en fin d'expression, 
aprés le dernier slash.<BR>Ainsi, le programme 14 pourrait être réécrit sous la 
forme. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg14bis.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
print ("Quelle est votre reponse ? ");
if (<STDIN> =~/^o/i) {
  print ("La reponse est oui.\n\n");
}
else {
  print ("La reponse est non.\n\n");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg14bis.pl<SPAN class=rouge>ent</SPAN>
Quelle est votre reponse ? Ouil<SPAN class=rouge>ent</SPAN>
La reponse est oui.
c:\progs&gt; perl reg14bis.pll<SPAN class=rouge>ent</SPAN>
Quelle est votre reponse ? Nonl<SPAN class=rouge>ent</SPAN>
La reponse est non.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Changement de délimiteur.</H2>
<H3>Il est possible que le caractère "/" doive être présent dans le modèle à 
rechercher. Il existe une possibilité, c'est de représenter le caractère en 
question au moyen de la chaîne "\/". </H3>
<H3>Exemple, soit à reconnaitre le modèle "/etc/passwd" dans une cible lue au 
clavier. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg15.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$path = <STDIN>;
if ($path =~ /^\/etc\/passwd/) {
  print ("Chaine reconnue");
} else {
  print ("Chaine inconnue");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg15.pl<SPAN class=rouge>ent</SPAN>
/etc/passwd<SPAN class=rouge>ent</SPAN>
Chaine reconnue
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Une autre solution consiste à changer le délimiteur identifiant l'expression 
régulière afinn que ce dernier ne soit plus le "/". Ce changement de délimiteur 
est spécifié par la lettre "m" (pour modify). </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg16.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$path = <STDIN>;
if ($path =~ m*^/etc/passwd*) {
# le delimiteur est maintenant * 
     print ("Chaine reconnue");
     }
   else {
     print ("Chaine inconnue");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg16.pl<SPAN class=rouge>ent</SPAN>
/etc/passwd<SPAN class=rouge>ent</SPAN>
Chaine reconnue

c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg16bis.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$path = <STDIN>;
if ($path =~ m&amp;^/etc/passwd&amp;) {
# le delimiteur est maintenant &amp;
     print ("Chaine reconnue");
     }
   else {
     print ("Chaine inconnue");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg16bis.pl<SPAN class=rouge>ent</SPAN>
/etc/passwd<SPAN class=rouge>ent</SPAN>
Chaine reconnue
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Les variables.</H2>
<H3>Afin de simplifier l'écriture des expressions régulières, le modèle peut 
être mémorisé dans une variabe. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg17.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$mot = "jour";
$cible = "Bonjour a tous.";
if ($cible =~ /$mot/) {
  print ("le nom : $nom\n");
  print ("contient la chaine : $mot\n");
} else {
  print ("Rien");
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg17.pl<SPAN class=rouge>ent</SPAN>
la cible: Bonjour a tous.
contient la chaine : jour
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On peut compliquer les choses. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg18.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "Bonjour a tous.";
print "Quel mot rechercher ?\n");
$mot = <STDIN>;
chop ($mot);
if ($cible =~ /$mot/) {
  print ("La cible : $nom\n");
  print ("contient : $mot\n");
} else {
else {
     print ("La cible : $mot ");
     print ("ne contient pas :$nom\n");

}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg18.pl<SPAN class=rouge>ent</SPAN>
Quel mot rechercher ?
bonjour<SPAN class=rouge>ent</SPAN>
La cible: Bonjour a tous.
ne contient pas : bonjour
c:\progs&gt; perl reg18.pl<SPAN class=rouge>ent</SPAN>
Quel mot rechercher ?
[bB]onjour<SPAN class=rouge>ent</SPAN>
La cible: Bonjour a tous.
contient : [bB]onjour
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Les variables liées aux expressions régulières.</H2>
<H3>Nous avons déjà évoqué la possibilité de mémoriser des éléments de la cible 
qui couvrent certains modèles afin de les réutiliser dans le corps de 
l'expression régulière.<BR>Ces variables qui sont référencées \1, \2, ..., \n 
dans le corps de l'expression sont aussi disponibles dans le corps de programme. 
Elles s'appellent respectivement $1, $2, ..., $n.<BR>Elles sont positionnées 
chaque fois qu'une mémorisation est demandée dans le corps d'une expression 
régulière.<BR>Reprenons l'exemple de la cible </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>"AA-aaa-BB-bbb-C-C-ccc-DD"
  </PRE></DIV></DIV>
<H3>A laquelle est soumise l'expression </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>s/A(.*)B(.*)C/X\1Y\2Z/
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg19.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "AA-aaa-BB-bbb-C-C-ccc-DD";
$cible =~ s/A(.*)B(.*)C/X\1Y\2Z/;
print ("Valeur de $1 : $1\n");
print ("Valeur de $2 : $2\n");
print ("Valeur finale de la cible :\n");
print ($cible"\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg19.pl<SPAN class=rouge>ent</SPAN>
Valeur de $1 : AA-aaa-B
Valeur de $2 : -bbb-C-
Valeur finale de la cible :
XA-aaa-BY-bbb-C-Z-ccc-DD
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Un moyen intéressant d'utiliser cette particularité pourrait être. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg20.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
chomp(<STDIN>);
($m1,$m2) = /(\w+)\W+(\w+)/;
print ("Premier mot : $m1\n");
print ("Second mot : $m2\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl eg20.pl<SPAN class=rouge>ent</SPAN>
Bonjour Monsieur
Premier mot : Bonjour
Second mot : Monsieur
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Il existe par ailleurs trois variables spécifiques prédéfinies. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Nom</TH>
    <TH>Contenu.</TH></TR>
  <TR>
    <TD>$&amp;</TD>
    <TD>Chaine qui couvre le modèle.</TD></TR>
  <TR>
    <TD>$`</TD>
    <TD>Partie qui précède le modèle.</TD></TR>
  <TR>
    <TD>$'</TD>
    <TD>Partie qui suit le modèle</TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg21.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "AA-aaa-BB-bbb-C-C-ccc-DD";
$cible =~ /(b+)/;
print ("Chaine reperee : $&amp;\n");
print ("Chaine qui precede : $`\n");
print ("Chaine qui suit : $'\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg21.pl<SPAN class=rouge>ent</SPAN>
Chaine reperee : bbb
Chaine qui precede : AA-aaa-BB-
Chaine qui suit : -C-C-ccc-DD
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Ces variables étant positionnées chaque fois qu'une expression régulière est 
utilisée, il est nécessaire, si on désire les utiliser plusieurs fois au cours 
du programme, de les mémoriser dans des variables déclarées. </H3>
<H2>Les options.</H2>
<TABLE>
  <TBODY>
  <TR>
    <TH>Options</TH>
    <TH>Action</TH></TR>
  <TR>
    <TD>g</TD>
    <TD>Pour general. Change toutes les occurences de la forme 
  sélectionnée</TD></TR>
  <TR>
    <TD>i</TD>
    <TD>Pour ignore case. Ignore le fait que la forme sélectionnée est en 
      majuscule ou en minuscule.</TD></TR>
  <TR>
    <TD>e</TD>
    <TD>Pour evaluate. Permet l'évaluation de la chaine de remplacement comme 
      une expression.</TD></TR>
  <TR>
    <TD>m</TD>
    <TD>Pour multiple lines. La chaine de test occupe plusieurs lignes.</TD></TR>
  <TR>
    <TD>o</TD>
    <TD>Pour one. L'évaluation n'a lieu qu'une fois.</TD></TR>
  <TR>
    <TD>s</TD>
    <TD>Pour single line. Le traitement n'a lieu que sur une ligne.</TD></TR>
  <TR>
    <TD>x</TD>
    <TD>Pour extended. Permet de présenter une expression régulière sur 
      plusieurs lignes.</TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg22.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "AA-aaa-BB-bbb-C-C-ccc-DD";
print ("Avant : $cible\n");
$cible =~ s/C/xx/;
print ("Apres : $cible\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg22.pl<SPAN class=rouge>ent</SPAN>
Avant : AA-aaa-BB-bbb-C-C-ccc-DD
Apres : AA-aaa-BB-bbb-xx-C-ccc-DD
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On substitue à la première occurence de "C" la chaîne "xx'. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg23.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "AA-aaa-BB-bbb-C-C-ccc-DD";
print ("Avant : $cible\n");
$cible =~ s/C/xx/g;
print ("Apres : $cible\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg23.pl<SPAN class=rouge>ent</SPAN>
Avant : AA-aaa-BB-bbb-C-C-ccc-DD
Apres : AA-aaa-BB-bbb-xx-xx-ccc-DD
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>L'option g (pour general) permet de forcer la substitution à toutes les 
occurence de "C". </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg24.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "AA-aaa-BB-bbb-C-C-ccc-DD";
print ("Avant : $cible\n");
$cible =~ s/C/xx/gi;
print ("Apres : $cible\n");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg24.pl<SPAN class=rouge>ent</SPAN>
Avant : AA-aaa-BB-bbb-C-C-ccc-DD
Apres : AA-aaa-BB-bbb-xx-xx-xxxxxx-DD
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>L'option g (pour general) et i (pour ignore case) permet de forcer la 
substitution à toutes les occurence de "C"qu'il se présente en majuscules ou en 
minuscules. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg25.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$cible = "AA-aaa-BB-bbb-C-C-ccc-DD";
print ("Avant : $cible\n");
$cible =~  s/(\w+)(\W+)/&lt;$1&gt;/g;
print "$cible\n";
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg25.pl<SPAN class=rouge>ent</SPAN>
Avant : AA-aaa-BB-bbb-C-C-ccc-DD
Apres : &lt;AA&gt;&lt;aaa&gt;&lt;BB&gt;&lt;bbb&gt;&lt;C&gt;&lt;C&gt;&lt;ccc&gt;&lt;DD&gt;
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On mémorise chaque mot et son séparateur (\w+)(\W+), on replace le mot 
mémorisé entre &lt;&gt; &lt;$1&gt; et on ne tient pas compte du séparateur. 
Cette opération est effectuée pour l'ensemble des éléments de la cible (option 
g). </H3>
<H3>Voici un problème clasique. On dispose d'un texte mal formaté. Pour le 
moment, nous ne considèrerons qu'il ne contient que des mots séparés par des 
espaces ou des tabulations. Il est stocké dans le fichier "texte.txt. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>                Ce texte   contient des         tas             
 d'espaces              et     de  tabulations          
 mal            placees.                
   le but    est de              le reformater     
        afin                 qu'il    soit presentable
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg26.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
@ARGV =("ttab.txt");
print "Texte reformate : \n\n");
while  ($ligne =&lt;&gt;) {
  $ligne =~s/^[ \t]+//;
  $ligne =~s/[ \t]+$//;
  $ligne =~s/[ \t]+/ /g;
  chomp($ligne);
print "-$ligne-\n";
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg26.pl<SPAN class=rouge>ent</SPAN>
Texte reformate :

-Ce texte contient des tas-
-d'espaces et de tabulations-
-mal placées.-
-le but est de le reformater-
-afin qu'il soit présentable.-
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>On utilise successivement trois expressions régulières.<BR>La première va 
supprimer les espaces et les tabulations en début de ligne.<BR>La seconde va 
supprimer les espaces et les tabulations en fin de ligne.<BR>La troisième va 
supprimer les espaces et les tabulations en les remplaçant par un unique espace. 
</H3>
<H2>L'évaluation d'une expression. </H2>
<H3>L'option e (pour evaluate) va permettre, lors d'une substition, de procéder 
à un calcul sur les variables qui auront été préalablement mémorisées.<BR>Par 
exemple, la cible contient une série de lettres suivis d'un chiffre. On desire 
dupliquer la chaîne de lettres autant de fois qu'indiqué par le chiffre qui 
suit.<BR>La chaîne </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>Ab2x4y6
  </PRE></DIV></DIV>
<H3>Doit donner après traitement. /h3&gt; 
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>AbAbxxxxyyyyyy
  </PRE></DIV></DIV>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg27.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!usr/bin/perl
$chaine = "Ab2x4y6";
print ("Chaine origine :\n");
print ("$chaine\n"=;
$chaine =~s/([a-zA-Z]+)(\d+)/$1 x $2/ge;
print ("Chaine apres traitement :\n");
print "$chaine\n";    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg27.pl<SPAN class=rouge>ent</SPAN>
Chaine origine :
Ab2x4y6 
Chaine apres traitement :
AbAbxxxxyyyyyy
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H3>Le champ de substitution contient une opération de multiplication de 
chaînes. on reproduit la chaîne contenue dans la variable $1 autant de fois que 
la valeur contenue dans la variable $2. </H3>
<H3>Autre exemple, on dispose d'un texte qui contient des caractères 
alphabétiques et des nombres </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>Le nombre entier un : 1.
Le nombre entier deux : 2.
Le nombre entier quatre : 4.
Le nombre entier huit : 8.
Et pourquoi pas le nombre entier cent : 100.
Cette egalité est vraie : 250 x 3 = 750.
Et on finit en donnant la date :
nous sommes le 22 Avril 2000.
  </PRE></DIV></DIV>
<H3>On souhaite multiplier tous les nombres de ce texte par 2. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme reg28.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
#!usr/bin/perl
@ARGV =("Txtnb.txt");
while  ($ligne = &lt;&gt;) {
     $ligne =~s/\d+/$&amp; * 2/eg;
     print "$ligne";
}
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl reg28.pl<SPAN class=rouge>ent</SPAN>
Le nombre entier un : 2.
Le nombre entier deux : 4.
Le nombre entier quatre : 8.
Le nombre entier huit : 16.
Et pourquoi pas le nombre entier cent : 200.
Cette egalité est vraie : 500 x 6 = 1500.
Et on finit en donnant la date :
nous sommes le 44 Avril 4000.
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Un petit exercice moyennement compliqué.</H2>
<H3>On va lire une date sous la forme aaaa/mm/jj. L'année sera compriose entre 
1900 et 2099. </H3>
<H3>On désire vérifier qu'elle est correcte, et en plus on indiquera si c'est 
une date du XX ème siècle (date&lt;2000) ou du XXI ème siècle (date&gt;1999) 
</H3>
<DIV class=centre style="WIDTH: 45em">
<DIV class=prog><PRE>c:\progs&gt; type date.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
print ("Donnez moi une date sous la forme aaaa-mm-jj : ");
chop ($date=<STDIN>);
$M31 = "(0[13578]|1[02]).(0[1-9]|[12]\\d|3[01])";
$M30 = "(0[469]|11).(0[1-9]|[12]\\d|30)";
$Mf = "02.(0[1-9]|[12]\\d)";
$xx = $date =~/^(19)\d\d.($M31|$M30|$Mf)$/;
$xxi = $date =~/^(20)?\d\d.($M31|$M30|$Mf)$/;
$ancienne = $date =~/^(d{1,4}).($M31|$M30|$Mf)$/;
if ($xx) {
  print ("$date est une date du XXème siècle qui semble valide.\n");
} elsif ($xxi) {
  print ("$date est une date du XXIème siècle qui semble valide.\n");
} elsif ($ancienne) {
  print ("$date n'est pas une date du XX eme siècle.\n");
} else {
  print ("$date ne semble pas etre une date valide.\n");
}
c:\progs&gt;
  </PRE></DIV></DIV>
<H3>Afin de faciliter l'ecriture et les explications, les modèles ont été 
stockés dans des variables. </H3>
<H3>La première forme. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>(0[13578]|1[02]).(0[1-9]|[12
  </PRE></DIV></DIV>
<H3>Affectée à la variable $M31, va permettre </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment><SPAN 
      class=rouge>(0[13578]|1[02])</SPAN>.(0[1-9]|[12]\\d|3[01]) </TD>
    <TD class=comment>De définir les mois de 31 jours (01, 03, 05, 07, 08, 10, 
      12). Ou bien un 0 suivi d'un des chiffres 1, 3, 5, 7, 8. Ou bien un 1 
      suivi d'un des chiffres 0, 2. </TD></TR>
  <TR>
    <TD class=comment>(0[13578]|1[02])<SPAN 
      class=rouge>.</SPAN>(0[1-9]|[12]\\d|3[01]) </TD>
    <TD class=comment>De sauter un caractère, le séparateur. </TD></TR>
  <TR>
    <TD class=comment>(0[13578]|1[02]).<SPAN 
      class=rouge>(0[1-9]|[12]\\d|3[01]) </SPAN></TD>
    <TD class=comment>De définir tous les nombres de 2 chiffres compris entre 
      01 et 31.<BR>Un 0 suivi d'un des chiffres 1 à 9.<BR>Un 1 ou un 2 ([12]) 
      suivi d'un des chiffres 0 à 9.<BR>Un 3 suivi d'un des chiffres 0 ou 1. 
  </TD></TR></TBODY></TABLE>
<H3>On a donc établi un rapport entre les mois de 31 jours et le numéro du jour 
qui doit être compris entre 1 et 31. </H3>
<H3>La seconde forme. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>(0[469]|11).(0[1-9]|[12]\\d|30)
  </PRE></DIV></DIV>
<H3>Affectée à la variable $M30, fait la même chose pour les mois de 30 jours. 
</H3>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment><SPAN class=rouge>(0[469]|11)</SPAN>.(0[1-9]|[12]\\d|30) 
    </TD>
    <TD class=comment>Définition des mois de 30 jours (04, 04, 04, 11). Un 0 
      suivi d'un des chiffres 4, 6, 9. Les deux chiffres 11. </TD></TR>
  <TR>
    <TD class=comment>(0[469]|11<SPAN class=rouge>.</SPAN>(0[1-9]|[12]\\d|30) 
    </TD>
    <TD class=comment>De sauter un caractère, le séparateur. </TD></TR>
  <TR>
    <TD class=comment>(0[1-9]|[12]\\d|30)<SPAN class=rouge>(0[1-9]|[12]\\d|30) 
      </SPAN></TD>
    <TD class=comment>De définir tous les nombres de 2 chiffres compris entre 
      01 et 3.<BR>Un 0 suivi d'un des chiffres 1 à 9.<BR>Un 1 ou un 2 ([12]) 
      suivi d'un des chiffres 0 à 9.<BR>Les deux chiffres 31. 
</TD></TR></TBODY></TABLE>
<H3>Le rapport est maintenant fait entre les mois de 30 jours et le numéro du 
jour qui doit être compris entre 1 et 30. </H3>
<H3>Reste à traiter le cas particulier du mois de février, grâce au modèle. 
</H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>02.(0[1-9]|[12]\\d)
  </PRE></DIV></DIV>
<H3>Qui est affectée à la variable $M, et qui va permettre. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD class=comment><SPAN class=rouge>02</SPAN>.(0[1-9]|[12]\\d) </TD>
    <TD class=comment>De définir le mois 02, février. </TD></TR>
  <TR>
    <TD class=comment>02<SPAN class=rouge>.</SPAN>(0[1-9]|[12]\\d) </TD>
    <TD class=comment>De sauter le séparateur </TD></TR>
  <TR>
    <TD class=comment>02.<SPAN class=rouge>(0[1-9]|[12]\\d) </SPAN></TD>
    <TD class=comment>Puis de définir tous les nombres de 2 chiffres compris 
      entre 01 et 29.<BR>Un 0 suivi d'un des chiffres 1 à 9.<BR>Un 1 ou un 2 
      ([12]) suivi d'un chiffre. </TD></TR></TBODY></TABLE>
<H3>Afin de ne pas trop compliquer le problème, nous avons volontairement ignoré 
le fait que le mois de février pouvait ne contenir que 28 jours. </H3>
<H3>Nous passons maintenant aux expressions régulières proprement dites. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>$xx = $date =~/^(19)\d\d.($M31|$M30|$Mf)$/;
  </PRE></DIV></DIV>
<H3>Teste si la date est du XX ème siècle, à savoir que les deux premiers 
caractères sont les chiffres 19 et que la suite correspond a l'une ou l'autre 
des définitions que nous avons données à propos des relations entre le mois et 
le nombre de jours. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>$xxi = $date =~/^(20)?\d\d.($M31|$M30|$Mf)$/;
  </PRE></DIV></DIV>
<H3>Teste si la date est du XXI ème siècle, à savoir que les deux premiers 
caractères sont les chiffres 20 et que la suite correspond a l'une ou l'autre 
des définitions que nous avons données à propos des relations entre le mois et 
le nombre de jours. </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>$ancienne = $date =~/^(d{1,4}).($M31|$M30|$Mf)$/;
  </PRE></DIV></DIV>
<H3>Teste simplement si la date est correcte, à savoir que les quatre premiers 
caractères sont des chiffres et que la suite correspond a l'une ou l'autre des 
définitions que nous avons données à propos des relations entre le mois et le 
nombre de jours.<BR>On indique alors qu'il s'agit d'une ancienne date, 
antérieure à 1900 </H3>
<H3>Si, en fin de compte, aucun des tests ne s'est avéré positif, on en déduit 
que l'expression de la date est incorrecte. </H3>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A href="http://www.dil.univ-mrs.fr/~chris/Perl/Hash.htm"><IMG 
style="VERTICAL-ALIGN: middle" 
src="Cours Perl, Les expressions régulières_fichiers/prec.gif"> </A>Précédent 
</DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Fnspec.htm"><IMG 
style="VERTICAL-ALIGN: middle" 
src="Cours Perl, Les expressions régulières_fichiers/suiv.gif"> 
</A></DIV></H2></H3></H3></H3></H2></BODY></HTML>
