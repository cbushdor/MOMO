<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0050)http://www.dil.univ-mrs.fr/~chris/Perl/Sockets.htm -->
<HTML><HEAD><TITLE>Cours Perl, Les sockets.</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Cours Perl, Les sockets_fichiers/Messtyles.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY>
<H1>Les sockets.</H1>
<H2>Résumé des fonctions système.</H2>
<TABLE width="80%" align=center border=2>
  <TBODY>
  <TR>
    <TH>Opération</TH>
    <TH>Entrée Standard</TH>
    <TH>Sortie Standard</TH>
    <TH>Erreur Standard</TH>
    <TH>Simultanéité</TH></TR>
  <TR>
    <TD>System ();</TD>
    <TD>Héritage du programme. </TD>
    <TD>Héritage du programme.</TD>
    <TD>Héritage duprogramme.</TD>
    <TD>non</TD></TR>
  <TR>
    <TD>quotes d'exécution.</TD>
    <TD>Héritage du programme.</TD>
    <TD>Chaines de caractèresen retour.</TD>
    <TD>Héritage du programme.</TD>
    <TD>non</TD></TR>
  <TR>
    <TD>open ();<BR>Gestionnaire de fichier en sortie</TD>
    <TD>Connection au gestionnaite de fichier.</TD>
    <TD>Héritage du programme.</TD>
    <TD>Héritage du programme.</TD>
    <TD>Tant que la fonction close() n'est pas rencontrée.</TD></TR>
  <TR>
    <TD>open ();<BR>Gestionnaire de fichier en entrée.</TD>
    <TD>Héritage du programme.</TD>
    <TD>Connection au gestionnaite de fichier.</TD>
    <TD>Héritage du programme.</TD>
    <TD>Tant que la fonction close() n'est pas rencontrée</TD></TR>
  <TR>
    <TD>fork<BR>wait<BR>exec</TD>
    <TD>Déterminée par l'usager.</TD>
    <TD>Déterminée par l'usager.</TD>
    <TD>Déterminée par l'usager.</TD>
    <TD>Déterminée par l'usager.</TD></TR></TBODY></TABLE>
<H2>Résumé des fonctions système.</H2>
<H3>Ce sont toutes des fonctions Unix.<BR>(Se référer au manuel unix pour leur 
utilisation) </H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>getgrent<BR>setgrent <BR>endgrent 
      <BR>getgrnam<BR>getgrid<BR>getnetent<BR>getnetbyaddr<BR>getnetbyname<BR>setnetent<BR>endnetent 
      <BR></TD>
    <TD>gethostbyaddr 
      <BR>gethostbyname<BR>gethostent<BR>sethostent<BR>endhostent<BR>getlogin<BR>getpgrp<BR>setpgrp<BR>getppid<BR>getpwnam<BR></TD>
    <TD>getpwuid<BR>getpwent 
      <BR>setpwent<BR>endpwent<BR>getpriority<BR>setpriority<BR>getprotoen<BR>getprotobyname<BR>getprotobynumber<BR>setprotoent<BR></TD>
    <TD>endprotoent<BR>getservent<BR>getservbyname 
      <BR>getservbyport<BR>setservent<BR>endservent<BR>chroot<BR>ioctl 
      <BR>alarm<BR>dump<BR></TD></TR></TBODY></TABLE>
<H2>Les sockets</H2>
<TABLE>
  <TBODY>
  <TR>
    <TD>bind<BR>listen<BR>accept<BR>connect<BR>shutdown<BR></TD>
    <TD>socketpair<BR>getsockopt<BR>setsockop<BR>getsockname<BR>getpeername<BR></TD></TR></TBODY></TABLE>
<H3>Perl fournit des fonctions pour créer et manipuler des sockets. </H3>
<H3>Leur présentation dans ce qui suit s'apparente fortement à la présentation 
des sockets en langage C. </H3>
<H3>Deux processus situés sur une même machine ou sur des machines distantes 
peuvent communiquer via une entité appelée socket. </H3>
<H2>Attributs du Socket.</H2>
<H3>Un numéro qui est un descripteur de la même nature que celui des fichiers. 
</H3>
<H3>Un domaine :<BR>Le domaine INTERNET (le domaine de la socket est alors 
appelé PF_INET)<BR>Le domaine UNIX (PF_UNIX).<BR>Un socket donnée ne peut 
communiquer qu'avec un autre socket du même domaine.<BR>Un socket du domaine 
INTERNET permet la communication avec des processus distants, alors qu'un socket 
du domaine UNIX est destinée uniquement aux communications internes à la 
machine. </H3>
<H3>Un protocole de communication sous-jacent, appelé le type de la socket. Il 
s'agit généralement :<BR>&gt; Soit du mode connecté qui garantit la fiabilité 
des échanges. Le type correspondant pour la socket est appelé SOCK_STREAM. Le 
protocole utilisé dans le domaine Internet est le protocole TCP.<BR>Soit du mode 
non connecté où on échange des paquets d'informations (datagrammes) de taille 
éseau bornée. La fiabilité de tels échanges n'est pas garantie par le 
protocole.<BR>Le type correspondant pour ($longueur,@adrs) ldu socket est appelé 
SOCK_GRAM.<BR>Le protocole utilisé dans le domaine Internet est UDP. </H3>
<H2>Création d'un Socket.</H2>
<H3>Appel de la fonction socket du module Socket. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>use socket;
  </PRE></DIV></DIV>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>socket (DESCR_SOCKET,$Domaine,$Type,$Protocole);
  </PRE></DIV></DIV>
<H3>Permet l'ouverture d'un socket. </H3>
<H2>Détail du descripteur DESCR_SOCKET.</H2>
<H3>$Domaine : entier précisant le domaine. (constantes PF_INET ou 
PF_UNIX).<BR>$Type : entier précisant le type. (constantes SOCK_STREAM ou 
SOCK_GRAM).<BR>$Protocole : entier précisant le numéro du protocole, récupéré à 
partir de son nom au moyen de la fonction getprotobyname.<BR></H3>
<H2>Attachement d'un socket.</H2>
<H3>Au descripteur de socket devra être attaché à une adresse. 
<H3>
<H3>L'adresse d'un socket du domaine Internet comporte deux composantes : </H3>
<H3>L'adresse Internet de la machine où se trouve la socket<BR>Un numéro de 
port. </H3>
<H3>Une application communique avec l'extérieur via un port précis d'une machine 
donnée. L'adresse d'un socket aura la forme d'une chaîne ($adr_sock). </H3>
<H3>Cette chaîne est un "package" de la structure binaire des données suivantes 
ordonnées :<BR>PF_INET (short non signé).<BR>Numéro du port (short).<BR>Adresse 
Internet de la machine (4 chaînes ASCII complétées à nul)<BR>8 octets à nul. 
</H3>
<H3>La fonction bind permet d'attacher une adresse.<BR>Exemple 
:<BR>Bind(DESCR_SCOCKET, $adr_sock);<BR>Attache l'adresse $adr_sock à la socket 
déjà ouverte de descripteur DESCR_SCOCKET. </H3>
<H2>Les fonctions getprotoby***.</H2>
<H3>getprotobyname permet récupérer le numéro à partir de son nom.<BR>La valeur 
de retour peut être une liste ou un scalaire.<BR>Dans un contexte de liste, ce 
sera :($nom,$alias,$proto_numb).<BR>Dans un contexte scalaire, ce sera 
:$proto_numb<BR></H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>$proto_numb= getprotobyname('TCP');
  </PRE></DIV></DIV>
<H3>getprotobynumber permet récupérer le nom d'un protocole à partir du 
numèro.<BR>La valeur de retour peut être une liste ou un scalaire.<BR>Dans un 
contexte de liste, ce sera :($nom,$alias,$proto_nom) <BR>Dans un contexte 
scalaire, ce sera : $proto_nom </H3>
<H2>Les fonctions gethostby***.</H2>
<H3>gethostbyname permet récupérer le numéro IP d'une machine à partir de son 
nom.<BR>La valeur de retour peut être une liste ou un scalaire.<BR>Dans un 
contexte de liste, ce sera : ($nom,$alias,$typeadr,$longueur,@adrs)<BR>@adrs est 
liste d'adresses "packées" dont le premier élément est l'adresse de 
l'hôte.<BR>Dans un contexte scalaire, ce sera l'adresse Internet.<BR></H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>$adresse_hote = gethostbyname( ’dil.univ-mrs.fr’);
  </PRE></DIV></DIV>
<H3>gethostbyaddr permet récupérer le nom d'une machine à partir de son numèro 
IP. </H3>
<H2>Exemple, de fonction gethostbyadr.</H2>
<DIV class=centre style="WIDTH: 50em">
<DIV class=prog><PRE>c:\progs&gt; type nom.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
print ("Donnez moi une adresse ethernet :\n");
$adresse_de_la_machine = &lt;STDIN&gt;;
$adresse_de_la_machine =~ s/^\s+|\s+$//g;
@bytes = split (/\./, $adresse_de_la_machine);
$adresse = pack ("C4", @bytes);
if (!(($nom,$alias,$type_adressage,$longueur,@liste_d_adresses =gethostbyaddr ($adresse, 2))) {
  die ("Address $adresse_de_la_machine not found.\n");
}
print ("Le nom principal de la machine est $nom\n");
if ($alias ne "") {
  print ("Les alias de la machine sont :\n");
  @liste_d_alias = split (/\s+/, $alias);
  for ($i = 0; $i &lt; @liste_d_alias; $i++) {
    print ("\t$liste_d_alias[$i]\n");
  }
}
c:\progs&gt; perl nom.pl<SPAN class=rouge>ent</SPAN>
Donnez moi une adresse ethernet :
139.124.14.50
Le nom principal de la machine est pc50
c:\progs&gt;
  </PRE></DIV></DIV>
<H2>Les fonctions getservby***.</H2>
<H3>getservbyname permet de récupérer le numéro de port correspondant à un nom 
de service (port) avec un protocole donné.<BR>Un nom de service qui correspond à 
un numéro de port (25 pour SMTP,...) et un nom de protocole (TCP) sont traduits 
en son numéro de port correspondant. </H3>
<H3>La valeur de retour peut être une liste ou un scalaire.<BR>Dans un contexte 
de liste, ce sera : ($nom,$alias,$port_numb,$proto) <BR>Dans un contexte 
scalaire, ce sera le numéro de port du service.<BR></H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>$port_numb= getservbyname('25','TCP');
  </PRE></DIV></DIV>
<H3>getservbyport est la fonction réciproque. </H3>
<H2>La fonction pack.</H2>
<H3>Un mot de cette fonction qui va être utilisée par la fonction bind.<BR>Elle 
prend une liste de valeurs qu'elle compacte en une structure binaire selon un 
modèle précisé. </H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Caractère</TH>
    <TH>Action</TH></TR>
  <TR>
    <TD>a</TD>
    <TD>Une chaine ascii, complétée à nul..</TD></TR>
  <TR>
    <TD>A</TD>
    <TD>Une chaine ascii, complétée à blanc.</TD></TR>
  <TR>
    <TD>b</TD>
    <TD>Une chaine de bits en ordre croissant.</TD></TR>
  <TR>
    <TD>B</TD>
    <TD>Une chaine de bits en ordre décroissant.<BR></TD></TR>
  <TR>
    <TD>c</TD>
    <TD>Une valeur caractère signée</TD></TR>
  <TR>
    <TD>C</TD>
    <TD>Une valeur caractère non signée.</TD></TR>
  <TR>
    <TD>d</TD>
    <TD>Un flotant double précision en format natif.</TD></TR>
  <TR>
    <TD>f</TD>
    <TD>Un flotant simple précision en format natif.</TD></TR>
  <TR>
    <TD>h</TD>
    <TD>Une chaine hexadécimale, demi octet de poids faible en premier.</TD></TR>
  <TR>
    <TD>H</TD>
    <TD>Une chaine hexadécimale, demi octet de poids fort en premier.</TD></TR>
  <TR>
    <TD>i</TD>
    <TD>Une valeur entière non signée.</TD></TR>
  <TR>
    <TD>l</TD>
    <TD>Une valeur longue signée.</TD></TR>
  <TR>
    <TD>L</TD>
    <TD>Une valeur longue non signée.</TD></TR>
  <TR>
    <TD>n</TD>
    <TD>Un entier court dans l'ordre réseau.</TD></TR>
  <TR>
    <TD>N</TD>
    <TD>Un entier long dans l'ordre réseau.</TD></TR>
  <TR>
    <TD>p</TD>
    <TD>Un pointeur sur une chaine.</TD></TR>
  <TR>
    <TD>P</TD>
    <TD>Un pointeur sur une structure.</TD></TR>
  <TR>
    <TD>s</TD>
    <TD>Une valeur courte signée.</TD></TR>
  <TR>
    <TD>S</TD>
    <TD>Une valeur courte non signée.</TD></TR>
  <TR>
    <TD>v</TD>
    <TD>Une valeur courte en 'short indian'.</TD></TR>
  <TR>
    <TD>V</TD>
    <TD>Une valeur longue en 'short indian'.</TD></TR>
  <TR>
    <TD>u</TD>
    <TD>Une chaine en format uuencode.</TD></TR>
  <TR>
    <TD>x</TD>
    <TD>Un octet à nul.</TD></TR>
  <TR>
    <TD>X</TD>
    <TD>Un arrière d'un octet.</TD></TR>
  <TR>
    <TD>@</TD>
    <TD>Remplissage à nul de la position absolue.</TD></TR></TBODY></TABLE>
<H2>Les champs de la fonction pack.</H2>
<H3>Chaque lettre est éventuellement suivie d'un chiffre (le compteur de 
répétitions). L'ensemble lettre-compteur donnent un spécificateur de 
champ.<BR>Les spécifications de champ dans le modèle peuvent être séparés pas 
des espaces, qui seront ignorés.<BR>Pour tous les types (à l'exeption de 'a' et 
'A') la fonction absorbe autant de valeurs de la liste que spécifiées par le 
compteur.<BR>'*' indique d'utiliser tous les éléments restants.<BR>Les chaines 
'a' et 'A' ne prennent en compte qu'une chaine, mais la 'packent' dans une 
chaine de longueur spécifiée en la complétant à blanc ou a nul si nécessaire. 
</H3>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme p1.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$resultat = pack("cccc",65,66,67,68);
print ("$resultat");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl p1.pl<SPAN class=rouge>ent</SPAN>
ABCD
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme p2.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$resultat = pack("c4",65,66,67,68);
print ("$resultat");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl p2.pl<SPAN class=rouge>ent</SPAN>
ABCD
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme p3.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$resultat = pack("B32","01010000011001010111001001101100");
print ("$resultat");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl p3.pl<SPAN class=rouge>ent</SPAN>
Perl
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TH>Programme p4.pl</TH>
    <TH>Exécution sur l'écran</TH></TR>
  <TR>
    <TD class=source><PRE>#!/usr/bin/perl;
$resultat = pack("H8","5065726c");
print ("$resultat");
    </PRE></TD>
    <TD class=prog><PRE>c:\progs&gt; perl p4.pl<SPAN class=rouge>ent</SPAN>
Perl
c:\progs&gt;
    </PRE></TD></TR></TBODY></TABLE>
<H2>Construction d'adresse.</H2>
<H3>Appel de la fonction pack </H3>
<DIV class=centre style="WIDTH: 30em">
<DIV class=prog><PRE>$adr_socket=pack('S n C4 x8',PF_INET,$port,$adresse_hote);
  </PRE></DIV></DIV>
<H3>$adresse_hote est l'adresse IP de la machine où se trouve le 
socket.<BR>$port est le numéro de port. <BR></H3>
<H2>Appel de la fonction sockaddr_in (depuis perl 5).</H2>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>$adr_socket=sockaddr_in($port,$adresse_hote);
  </PRE></DIV></DIV>
<H3>$adresse_hote est l'adresse IP de la machine où se trouve le 
socket.<BR>$port est le numéro de port. <BR></H3>
<H3>L'opération inverse à la construction d'une adresse de socket sera utile 
lors de l'écriture de programmes serveur TCP. On peut ici aussi utiliser la 
fonction sockaddr_in.<BR>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>($port,$adresse_hote)=sockaddr_in($adr_socket);
  </PRE></DIV></DIV>
<H3>$port contiendra le numéro de port. <BR>$adresse_hote contiendra l'adresse 
IP de la machine où se trouve la socket d'adresse $adr_socket. </H3>
<H2>La fonction socket.</H2>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>socket (nom, domaine, type, format);
  </PRE></DIV></DIV>
<H3>nom est une variable de fichier associée à la prise.<BR>domain représente la 
famille de protocole.<BR>type indique le type de prise à créer.<BR>format est le 
numéro du protocole associé à la prise, (généralement trouvé par la fonction 
getprotobyname).<BR></H3>
<H3>La valeur de retour sera zéro si il y a eu un problème, toute autre valeur 
dans le cas contraire. </H3>
<H3>domain : les valeurs admises pour cette variable sont listées dans l'en tête 
du fichier /usr/include/sys/socket.h; ces valeurs sont représentées par les 
constantes :<BR>PF_UNIX<BR>PF_INET<BR>PF_IMPLINK<BR>PF_NS </H3>
<H3>type : Les valeurs admises pour cette variable listées dans l'en tête du 
fichier /usr/include/sys/socket.h; ces valeurs sont représentées par les cinq 
constantes 
:<BR>SOCK_STREAM<BR>SOCK_DGRAM<BR>SOCK_RAW<BR>SOCK_SEQPACKET<BR>SOCK_RDM. 
<BR></H3>
<H2>La fonction bind.</H2>
<H3>Aprés la création de la prise, l'étape suivante consiste à lier (bind) la 
prise à une adresse particulière de réseau. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>bind (prise,adresse);
  </PRE></DIV></DIV>
<H3>prise réfère au nom de fichier préalablement créé par la fonction 
socket.<BR>adresse est l'adresse du réseau associé à la prise.<BR></H3>
<H3>L'adresse est constituée de trois éléments qui sont :<BR>Le type de 
l'adresse (entier non signé) est toujours AF_INET (défini dans 
/usr/include/netdb.h ou /usr/include/bsd/netdb.h). <BR>Le numéro du port à 
utiliser lors de la connection.<BR>L'adresse internet de la machine sous la 
forme d'un ensemble de 4 octets. Cette adresse est généralement créée par 
l'intermédiaire de pack. </H3>
<DIV class=centre style="WIDTH: 35em">
<DIV class=prog><PRE>$adresse = pack ("Sna4x8",2,$numero_de_port, $adresse_internet);
  </PRE></DIV></DIV>
<H3>S : Un entier court non signé.<BR>n : Un entier court dans l'ordre 
réseau.<BR>a : Suivi du répétiteur 4, une chaine ascii de 4 caractères 
(l'adresse).<BR>x : Suivi du répétiteur 8, une suite de 8 octets à nul (\0). 
</H3>
<H2>La fonction listen.</H2>
<H3>Aprés avoir lié une adresse associée à chacune des machines avec lesquelles 
la communication doit se faire, il est nécessaire de définir un process qui 
écoutera.<BR>Ce process va attendre que la communication soit établie avec 
lui.<BR>Cette opération se fait par la fonction listen.<BR></H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>listen (prise,nombre);
  </PRE></DIV></DIV>
<H3>prise est la prise créée par la fonction socket.<BR>nombre est le nombre 
maximum de process qui peuvent être stockés dans la file d'attente. </H3>
<H3>Si tout s'est bien passé, la fonction listen retourne une valeur diférente 
de zéro. </H3>
<H3>Généralement, le nombre maximum de fichiers qui peuvent être stockés en 
liste d'attente est limité par le système d'exploitation. </H3>
<H2>La fonction accept.</H2>
<H3>Dés que la liaison a été établie, la fonction accept va se mettre en attente 
jusqu'à ce qu'un process demande une connection.<BR>Elle lui retournera alors 
une adresse. </H3>
<DIV class=centre style="WIDTH: 20em">
<DIV class=prog><PRE>accept (prise_du_process,prise);
  </PRE></DIV></DIV>
<H3>prise_du_process est une variable (préalablement undef) qui représentera la 
connection nouvellement créée.<BR>Le process qui est à l'écoute peut recevoir ou 
envoyer de l'information en utilisant la variable de fichier spécifiée.<BR>Cette 
variable de fichier sera utilisée comme toutes les autres par les commandes 
print et write ou en utilisantl'opérateur diamant &lt;&gt;.<BR>prise est la 
prise créée par la fonction socket et liée par la fonction bind. </H3>
<H2>La fonction connect.</H2>
<H3>Pour finir, la fonction connect va permettre de se connecter à un process 
qui attend une connection suite à un accept. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>connect (prise,adresse);
  </PRE></DIV></DIV>
<H3>prise est la variable de fichier représentative de la prise créée par la 
fonction socket et liée par la fonction bind.<BR>adresse est l'adresse internet 
à laquelle on désire se connecter. </H3>
<H3>Pour fermer un socket, on fait appel à la fonction close. </H3>
<DIV class=centre style="WIDTH: 15em">
<DIV class=prog><PRE>close(DESCR_SOCKET);
  </PRE></DIV></DIV>
<H2>Un serveur en mode connecté.</H2>
<H3>Principe du serveur.<BR>Le serveur reçoit les demandes de connexion des 
clients sur un socket d'écoute lié au port qui correspond au service assuré. Il 
se met alors en position d'accepter une connexion.<BR>L'acceptation d'une 
connexion crée un socket de service, c'est ce socket qui rendra le service au 
client. </H3>
<H2>Construction du serveur.</H2>
<H3>Fonctions socket et bind pour créer et attacher le socket 
d'écoute.<BR>Fonction listen pour écouter une connection.<BR>On boucle sur 
:<BR>Fonction accept qui attend une connection et crée le socket de service dès 
qu'une connexion est effectuée. <BR>Exécution du service <BR>Fermeture du socket 
de service <BR>Fin de la boucle </H3>
<H2>Construction du client en mode connecté.</H2>
<H3>Fonction socket pour créer le socket qui sollicitera le 
service.<BR>Construction de l'adresse du socket du serveur. <BR>1. Fonction 
connect pour demander la connexion au processus serveur.<BR>2. Mise en route du 
service (requêtes/réponses).<BR>Fermeture du socket. </H3>
<H2>la liaison client / serveur par la méthode traditionnelle.</H2>
<H3>Le serveur. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>c:\progs&gt; type serveur1.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
use Socket;
$| = 1;
#Message qui sera envoyé a la machine.
$ligne = ("Bonjour la machine..\n");
#Définition d'un port de départ pour la recherche.
$port = 2000;
#Recherche d'un port libre.
while (getservbyport ($port, "tcp")) {
  $port++
}
#Le port a été trouve,
#Son numero est maintenant dans le scalaire $port.
#On traduit le nom du protocole en son numéro.
$numero = getprotobyname ("tcp");
#On traduit le nom de la machine en son adresse (packee).
$identification = gethostbyname ("maccat");
#On récupère l'adresse internet de la machine.
$adresse_du_serveur = pack ("Sna4x8", AF_INET, $port, $identification);
#On crée la variable de fichier SERVEUR attachée au protocole.
socket (SERVEUR, PF_INET, SOCK_STREAM, $numero) || die ("Pas de prise\n");
#On associe la variable de fichier SERVEUR a notre machine.
bind (SERVEUR, $adresse_du_serveur) || die ("Liaison impossible.\n");
#On écoute la prise ainsi validée.
#Seul un process peut se mettre en file d'attente.
listen (SERVEUR, 1) || die ("Pas moyen d'ecouter.\n");
#On attend qu'un client se connecte.
#Une nouvelle variable de fichier (CLIENT) est alors créé.
($adresse_du_client = accept (CLIENT, SERVEUR)) |
die ("Pas moyen d'accepter.\n");
#L'adresse du client est maintenant dans la variable $adresse_du_client.
#On est dans une structure classique.
#On sélectionne la sortie (CLIENT) sur laquelle on va écrire.
select (CLIENT);
#On envoie la chaîne de caractères au client.
print CLIENT ("$ligne\n");
#On ferme tout.
close (CLIENT);
close (SERVEUR);
#Et c'est fini...
c:\progs&gt;
  </PRE></DIV></DIV>
<H3>Le client. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>c:\progs&gt; type client1.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
use Socket;
$| = 1;
#Définition d'un port de départ pour la recherche.
$port = 2000;
#Recherche d'un port libre.
while (getservbyport ($port, "tcp")) {
  $port++
}
#Le port a été trouvé. Son numéro est maintenant dans le scalaire $port.
#On traduit le nom du protocole en son numéro.
$numero = getprotobyname ("tcp");
#On traduit le nom de la machine serveur en son adresse (packee).
$identification_serveur = gethostbyname ("maccat");
#On récupère l'adresse internet de la machine.
#et on n crée la variable de fichier CLIENT attachée au protocole.
$adresse_du_serveur = pack ("Sna4x8", AF_INET, $port,
socket (CLIENT, PF_INET, SOCK_STREAM, $numero) ||
die ("Pas de prise.\n");
#On ouvre une connection vers le serveur
#par l'intermédiaire de la variable de fichier CLIENT.
connect (CLIENT, $adresse_du_serveur);
#On récupère l'information qui arrive sur la ligne.
$line = <CLIENT>;
#On l'imprime.
print ("$line\n");
#Et on ferme la ligne.
close (CLIENT);
c:\progs&gt;
  </PRE></DIV></DIV>
<H2>En Perl 5.</H2>
<H3>Perl 5 offre de nombreuses simplifications par rapport à la méthode 
traditionnelle de type C que nous venons de présenter et qui était celle de 
Perl4.<BR>&gt; Il permet de se passer de la commande pack, de sotre que la 
fonction bind qui, en perl 4, nécessitait les deux instructions. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>$adresse_du_serveur = pack ("Sna4x8", AF_INET, $port, $identification);
bind (SERVEUR, $adresse_du_serveur);
  </PRE></DIV></DIV>
<H3>S'écrit beaucoup plus facilement en Perl 5 sous la forme. </H3>
<DIV class=centre style="WIDTH: 25em">
<DIV class=prog><PRE>bind (SERVEUR, sockaddr_in($port, INADDR_ANY));
  </PRE></DIV></DIV>
<H3>Le serveur. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>c:\progs&gt; type serveur2.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
use Socket;
$| = 1;
#Message qui sera envoyé a la machine.
$ligne = ("Bonjour la machine..");
#Définition d'un port de départ pour la recherche.
$port = 2000;
#Recherche d'un port libre.
while (getservbyport ($port, "tcp")) {
  $port++
}
#Le port a été trouve, Son numéro est maintenant dans le scalaire $port.
#On traduit le nom du protocole en son numéro.
$numero = getprotobyname ("tcp");
#On crée la variable de fichier SERVEUR attachée au protocole.
socket (SERVEUR, PF_INET, SOCK_STREAM, $numero) or
  die ("Pas moyen de creer de socket.\n");
#On associe la variable de fichier SERVEUR a notre machine.
bind (SERVEUR, sockaddr_in($port, INADDR_ANY)) or
  die ("Impossible de lier le port $port\n");
#On écoute la prise ainsi validée.
#Seul un process peut se mettre en file d'attente.
listen (SERVEUR, 1) or die ("Impossible d'ecouter.\n");
print ("Le serveur ecoute sur le port $port..\n");
print ("Attente de connection.\n");
#On attend qu'un client se connecte.
#Une nouvelle variable de fichier (CLIENT) est alors créé.
($client = accept (CLIENT, SERVEUR)) or die ("L'acceptation a echoue.\n");
($port, @ip) = unpack_sockaddr_in $client;
print "Connection acceptee de", inet_ntoa(@ip), ":$port\n";
print ("Envoi du message\n");
#On envoie la chîine de caractères au client.
print CLIENT ("$ligne");
print ("Fermeture de la connection.\n");
#On ferme tout.
close (CLIENT);
close (SERVEUR);
c:\progs&gt;
  </PRE></DIV></DIV>
<H3>Le client. </H3>
<DIV class=centre style="WIDTH: 40em">
<DIV class=prog><PRE>c:\progs&gt; type client2.pl<SPAN class=rouge>ent</SPAN> 
#!/usr/bin/perl
use Socket;
$| = 1;
#Définition d'un port de départ pour la recherche.
$port = 2000;
#Recherche d'un port libre.
while (getservbyport ($port, "tcp")) {
  $port++
}
#Le port a été trouve, Son numéro est maintenant dans le scalaire $port.
#On traduit le nom du protocole serveur en son numéro.
$numero = getprotobyname ("tcp");
#On traduit le nom de la machine serveur en son adresse (packee).
$serveur = gethostbyname ("maccat");
socket (CLIENT, PF_INET, SOCK_STREAM, $numero) or
die ("Pas moyen de creer de socket.\n");
print "connecting to ", inet_ntoa($serveur), ":$port.. ";
#On crée la variable de fichier CLIENT attachée au protocole.
connect (CLIENT, sockaddr_in($port, $serveur)) or
die ("Connection impossible.\n");
print ("Connection etablie.\n\n");
#On récupère l'information qui arrive sur la ligne.
$ligne = <CLIENT>;
#On l'imprime.
print ("Information recue : '$ligne'\n"); close (CLIENT);
  </PRE></DIV></DIV>
<H2>Un serveur de clients multiples.</H2>
<H3>Le serveur TCP qui vient d'être décrit ne peut traiter plusieurs clients 
simultanément.<BR>Dés que le programme serveur est occupé avec un client il doit 
attendre que le service se libère pour en traiter un nouveau. </H3>
<H3>On pourrait imaginer un serveur destiné à traiter simultanément plusieurs 
clients qui, pour assurer ce service, devrait se clonerau moyen de la fonction 
fork, engendrant de ce fait une copie du processus qui délivre le service. </H3>
<H3>Le principe général est. </H3>
<H3>Le processus père demeure en permanence à l'écoute en se bloquant sur un 
accept.<BR>Dés qu'une requête de connexion lui parvient, il se clone 
(fork()).<BR>La fonction retourne zéro (faux) si on est dans le processus fils, 
ou le numéro (pid) du process si le processus est le père.<BR>Alors que le 
processus père continue à bloquer sur accept dans l'attente d'une nouvelle 
requète, le processus fils, exécute le bloc le concernant.<BR>Comme il possède 
une copie de l'environnement de son père dont il partage tous les descripteurs 
de fichiers et de sockets ouverts, il peut sans aucun problème lire et écrire 
sur le socket de service créée par accept.<BR>Il ferme le socket d'écoute qu'il 
ne va pas utiliser, ce socket restant néanmoins ouvert pour le père. </H3>
<H2 style="POSITION: relative; HEIGHT: 5em">
<DIV class=lieng><A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/Clones.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Les sockets_fichiers/prec.gif"> 
</A>Précédent </DIV>
<DIV class=liend>Suivant <A 
href="http://www.dil.univ-mrs.fr/~chris/Perl/References.htm"><IMG 
style="VERTICAL-ALIGN: middle" src="Cours Perl, Les sockets_fichiers/suiv.gif"> 
</A></DIV></H2></H3></H3></H3></BODY></HTML>
