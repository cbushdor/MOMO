package packages::MyCrypto;

# +-------------------------------+
# | Dorey Sebastien               |
# | MyCrypt.pm                    |
# | Written     on Oct 13rd 2005  |
# | Last update on Oct 13rd 2005  |
# +-------------------------------+
  
require Exporter;

$VERSION    = '1.0';
$VERSION    = eval $VERSION;
@ISA    = qw( Exporter );
@EXPORT = qw( 
	      create_keys
	      jarriquez_423_encrypt       jarriquez_423_decrypt
	      jarriquez_givenKey_encrypt  jarriquez_givenKey_decrypt
	      );
@EXPORT_OK = qw( );


use packages::MyTime;

# Create a serie of keys in order 
sub create_keys {
    return (&transform_date_to_key(get_digital_date_format));
}

# Crypt with an already formated key that is 423
# Jarriquez is the guy in the novel 'La Jangada' of Jules Vernes who discover
# this code (for sure)
sub jarriquez_423_encrypt {
    my ($sentence) = @_;
    my @key = (4,2,3);
    my $key_l = @key;
    my $transformed_sentence = ();
    my $l = 0;
    my $i = 0;

    $sentence =~ s/[\ \*]//g;
    chomp($sentence);
    while ($l != length($sentence)) { # Begin  while ($l != length($sentence))
	my $p = substr($sentence,$l,1);
	my $value = (ord($p) + $key[$i]);

	$transformed_sentence .= chr($value % 128);
	$i++;
	$i = $i % $key_l;
	$l++;
    } # End while ($l != length($sentence))
    return $transformed_sentence;
}

# Crypt with a given key
sub jarriquez_givenKey_encrypt {
    my ($sentence,@key) = @_;
    my @defined_alphabet = &init_new_alphabet(32,126);
    my $size_of_new_defined_alphabet = @defined_alphabet;
    my $key_l = @key;
    my $transform_sentence = ();
    my $length_sentence = 0;
    my $i = 0;

    chomp($sentence);
    while ($length_sentence != length($sentence)) { # Begin  while ($length_sentence != length($sentence))
	my $p = substr($sentence,$length_sentence,1);
	my $rank = &get_rank_within_new_alphabet($p,@defined_alphabet);
	my $my_ord = ($rank + $key[$i]) % $size_of_new_defined_alphabet;

	$transform_sentence .=  $defined_alphabet[$my_ord];
	$i++;
	$i = $i % $key_l;
	$length_sentence++;
    } # End while ($length_sentence != length($sentence))
    return $transform_sentence;
}

# Crypt with a given key
sub jarriquez_givenKey_decrypt {
    my ($sentence,@key) = @_;
    my @defined_alphabet = &init_new_alphabet(32,126);
    my $size_of_new_defined_alphabet = @defined_alphabet;
    my $key_l = @key;
    my $decrypted_sentence = ();
    my $length_sentence = 0;
    my $i = 0;

    chomp($sentence);
    while ($length_sentence != length($sentence)) { # Begin  while ($length_sentence != length($sentence))
	my $p = substr($sentence,$length_sentence,1);
	my $rank = &get_rank_within_new_alphabet($p,@defined_alphabet);
	my $my_ord = ($rank - $key[$i]) % $size_of_new_defined_alphabet;

	$decrypted_sentence .=  $defined_alphabet[$my_ord];
	print "$p -- $rank    $my_ord " . $defined_alphabet[$my_ord]  . "\n";
	$i++;
	$i = $i % $key_l;
	$length_sentence++;
    } # End while ($length_sentence != length($sentence))
    return $decrypted_sentence;
}

# Get rank from a given char within new alphabet
sub get_rank_within_new_alphabet {
    my ($char,@alphabet) = @_;
    my $rank = 0;

    foreach (@alphabet) {
	if ("$char" eq "$_") {
#	    print "$char eq $_ : $rank\n";
	    return $rank;
	}
	$rank++;
    }
}

# Init my alphabet
sub init_new_alphabet {
    my ($begin,$end) = @_;
    my @new_alphabet = ();
    my $forbidden_char = ord('*');

    foreach ($begin..$end) { # Begin  foreach ($begin..$end)
	if ($_ != $forbidden_char) { # Begin if ($new_char != '*')
	    @new_alphabet = (@new_alphabet,chr($_));
	} # End if ($new_char != '*')
    }  # End  foreach ($begin..$end)
#    foreach (@new_alphabet) { # Begin  foreach ($begin..$end)
#	print $_ . "\n";
#    }
    return @new_alphabet;   
}

# Decrypt with an already given key that is 423
sub jarriquez_423_decrypt {
    my ($sentence) = @_;
    my @key = (4,2,3);
    my $key_l = @key;
    my $transform_sentence = ();
    my $length_sentence = 0;
    my $i = 0;

    chomp($sentence);
    while ($length_sentence != length($sentence)) {
	my $p = substr($sentence,$length_sentence,1);
	$transform_sentence .= (chr(ord($p) - $key[$i]) % $key_l);
	$i++;
	$i = $i % $key_l;
	$length_sentence++;
    }
    return $transform_sentence;
}

# We transform a given date to an array  to create keys to crypt data
sub transform_date_to_key {
    my ($given_date) = @_;
    chomp($given_date);
    my ($date,$time) = split(/\ /,$given_date);
    my @my_date = split(/\//,$date);
    my @new_date = ($my_date[0],$my_date[1],substr($my_date[2],0,2) * substr($my_date[2],2,2));

    @last = (@new_date,split(/\:/,$time));

    return (@last);
}

1;
